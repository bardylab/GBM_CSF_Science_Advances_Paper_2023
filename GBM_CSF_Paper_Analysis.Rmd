---
title: "RNAseq analysis"
author: "Inushi De Silva"
date: '2022-07-12'
output: github_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options("yaml.eval.expr" = TRUE)
```

1.  ***First we will load the required libraries and set workingdirectories, datadirectories and plotdirectories.***

```{Load Libraries and Set Directory Paths}
script_path <- rstudioapi::getActiveDocumentContext()$path
script_dir <- dirname(script_path)
setwd(script_dir)
workingdirectory <- paste0(script_dir)
datadirectory <- paste0(workingdirectory,"/data")
resultsdirectory <- paste0(workingdirectory, "/results")
cell_line_directory <- paste0(datadirectory,"/RData")
##dir.create(resultsdirectory)

## Load required libraries
if(!require(dplyr)){
  install.packages("dplyr")
  library(dplyr)
}
if(!require(Seurat)){
  install.packages("Seurat")
  library(Seurat)
}
if(!require(ggplot2)){
  install.packages("ggplot2")
  library(ggplot2)
}
if(!require(sctransform)){
  install.packages("sctransform")
  library(sctransform)
}
if(!require(RColorBrewer)){
  install.packages("RColorBrewer")
  library(RColorBrewer)
}
if(!require(ggpointdensity)){
  install.packages("ggpointdensity")
  library(ggpointdensity)
}
if(!require(fgsea)){
 BiocManager::install("fgsea")
  library(fgsea)
}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("simplifyEnrichment")
##For the latest version
library(devtools)
install_github("jokergoo/simplifyEnrichment")
```

1b.  **Load functions for downstream analyses**
```{Function for DoMultiBarHeatmap}
# Create function for DoHeatmap with multiple annotation
suppressPackageStartupMessages({
  library(rlang)
})
DoMultiBarHeatmap <- function (object, 
                               features = NULL, 
                               cells = NULL, 
                               group.by = "ident", 
                               additional.group.by = NULL, 
                               additional.group.sort.by = NULL, 
                               cols.use = NULL,
                               group.bar = TRUE, 
                               disp.min = -2.5, 
                               disp.max = NULL, 
                               slot = "scale.data", 
                               assay = NULL, 
                               label = TRUE, 
                               size = 5.5, 
                               hjust = 0, 
                               angle = 45, 
                               raster = TRUE, 
                               draw.lines = TRUE, 
                               lines.width = NULL, 
                               group.bar.height = 0.02, 
                               combine = TRUE) 
{
  cells <- cells %||% colnames(x = object)
  if (is.numeric(x = cells)) {
    cells <- colnames(x = object)[cells]
  }
  assay <- assay %||% DefaultAssay(object = object)
  DefaultAssay(object = object) <- assay
  features <- features %||% VariableFeatures(object = object)
  ## Why reverse???
  features <- rev(x = unique(x = features))
  disp.max <- disp.max %||% ifelse(test = slot == "scale.data", 
                                   yes = 2.5, no = 6)
  possible.features <- rownames(x = GetAssayData(object = object, 
                                                 slot = slot))
  if (any(!features %in% possible.features)) {
    bad.features <- features[!features %in% possible.features]
    features <- features[features %in% possible.features]
    if (length(x = features) == 0) {
      stop("No requested features found in the ", slot, 
           " slot for the ", assay, " assay.")
    }
    warning("The following features were omitted as they were not found in the ", 
            slot, " slot for the ", assay, " assay: ", paste(bad.features, 
                                                             collapse = ", "))
  }
  
  if (!is.null(additional.group.sort.by)) {
    if (any(!additional.group.sort.by %in% additional.group.by)) {
      bad.sorts <- additional.group.sort.by[!additional.group.sort.by %in% additional.group.by]
      additional.group.sort.by <- additional.group.sort.by[additional.group.sort.by %in% additional.group.by]
      if (length(x = bad.sorts) > 0) {
        warning("The following additional sorts were omitted as they were not a subset of additional.group.by : ", 
                paste(bad.sorts, collapse = ", "))
      }
    }
  }
  
  data <- as.data.frame(x = as.matrix(x = t(x = GetAssayData(object = object, 
                                                             slot = slot)[features, cells, drop = FALSE])))
  
  object <- suppressMessages(expr = StashIdent(object = object, 
                                               save.name = "ident"))
  group.by <- group.by %||% "ident"
  groups.use <- object[[c(group.by, additional.group.by[!additional.group.by %in% group.by])]][cells, , drop = FALSE]
  plots <- list()
  for (i in group.by) {
    data.group <- data
    if (!is_null(additional.group.by)) {
      additional.group.use <- additional.group.by[additional.group.by!=i]  
      if (!is_null(additional.group.sort.by)){
        additional.sort.use = additional.group.sort.by[additional.group.sort.by != i]  
      } else {
        additional.sort.use = NULL
      }
    } else {
      additional.group.use = NULL
      additional.sort.use = NULL
    }
    
    group.use <- groups.use[, c(i, additional.group.use), drop = FALSE]
    
    for(colname in colnames(group.use)){
      if (!is.factor(x = group.use[[colname]])) {
        group.use[[colname]] <- factor(x = group.use[[colname]])
      }  
    }
    
    if (draw.lines) {
      lines.width <- lines.width %||% ceiling(x = nrow(x = data.group) * 
                                                0.0025)
      placeholder.cells <- sapply(X = 1:(length(x = levels(x = group.use[[i]])) * 
                                           lines.width), FUN = function(x) {
                                             return(Seurat:::RandomName(length = 20))
                                           })
      placeholder.groups <- data.frame(rep(x = levels(x = group.use[[i]]), times = lines.width))
      group.levels <- list()
      group.levels[[i]] = levels(x = group.use[[i]])
      for (j in additional.group.use) {
        group.levels[[j]] <- levels(x = group.use[[j]])
        placeholder.groups[[j]] = NA
      }
      
      colnames(placeholder.groups) <- colnames(group.use)
      rownames(placeholder.groups) <- placeholder.cells
      
      group.use <- sapply(group.use, as.vector)
      rownames(x = group.use) <- cells
      
      group.use <- rbind(group.use, placeholder.groups)
      
      for (j in names(group.levels)) {
        group.use[[j]] <- factor(x = group.use[[j]], levels = group.levels[[j]])
      }
      
      na.data.group <- matrix(data = NA, nrow = length(x = placeholder.cells), 
                              ncol = ncol(x = data.group), dimnames = list(placeholder.cells, 
                                                                           colnames(x = data.group)))
      data.group <- rbind(data.group, na.data.group)
    }
    
    order_expr <- paste0('order(', paste(c(i, additional.sort.use), collapse=','), ')')
    group.use = with(group.use, group.use[eval(parse(text=order_expr)), , drop=F])
    
    plot <- Seurat:::SingleRasterMap(data = data.group, raster = raster, 
                                     disp.min = disp.min, disp.max = disp.max, feature.order = features, 
                                     cell.order = rownames(x = group.use), group.by = group.use[[i]])
    
    if (group.bar) {
      pbuild <- ggplot_build(plot = plot)
      group.use2 <- group.use
      cols <- list()
      na.group <- Seurat:::RandomName(length = 20)
      for (colname in rev(x = colnames(group.use2))) {
        if (colname == i) {
          colid = paste0('Identity (', colname, ')')
        } else {
          colid = colname
        }
        
        # Default
        cols[[colname]] <- c(scales::hue_pal()(length(x = levels(x = group.use[[colname]]))))  
        
        #Overwrite if better value is provided
        if (!is_null(cols.use[[colname]])) {
          req_length = length(x = levels(group.use))
          if (length(cols.use[[colname]]) < req_length){
            warning("Cannot use provided colors for ", colname, " since there aren't enough colors.")
          } else {
            if (!is_null(names(cols.use[[colname]]))) {
              if (all(levels(group.use[[colname]]) %in% names(cols.use[[colname]]))) {
                cols[[colname]] <- as.vector(cols.use[[colname]][levels(group.use[[colname]])])
              } else {
                warning("Cannot use provided colors for ", colname, " since all levels (", paste(levels(group.use[[colname]]), collapse=","), ") are not represented.")
              }
            } else {
              cols[[colname]] <- as.vector(cols.use[[colname]])[c(1:length(x = levels(x = group.use[[colname]])))]
            }
          }
        }
        
        # Add white if there's lines
        if (draw.lines) {
          levels(x = group.use2[[colname]]) <- c(levels(x = group.use2[[colname]]), na.group)  
          group.use2[placeholder.cells, colname] <- na.group
          cols[[colname]] <- c(cols[[colname]], "#FFFFFF")
        }
        names(x = cols[[colname]]) <- levels(x = group.use2[[colname]])
        
        y.range <- diff(x = pbuild$layout$panel_params[[1]]$y.range)
        y.pos <- max(pbuild$layout$panel_params[[1]]$y.range) + y.range * 0.015
        y.max <- y.pos + group.bar.height * y.range
        pbuild$layout$panel_params[[1]]$y.range <- c(pbuild$layout$panel_params[[1]]$y.range[1], y.max)
        
        plot <- suppressMessages(plot + 
                                   annotation_raster(raster = t(x = cols[[colname]][group.use2[[colname]]]),  xmin = -Inf, xmax = Inf, ymin = y.pos, ymax = y.max) + 
                                   annotation_custom(grob = grid::textGrob(label = colid, hjust = 0, gp = gpar(cex = 0.75)), ymin = mean(c(y.pos, y.max)), ymax = mean(c(y.pos, y.max)), xmin = Inf, xmax = Inf) +
                                   coord_cartesian(ylim = c(0, y.max), clip = "off")) 
        
        if ((colname == i) && label) {
          x.max <- max(pbuild$layout$panel_params[[1]]$x.range)
          x.divs <- pbuild$layout$panel_params[[1]]$x.major %||% pbuild$layout$panel_params[[1]]$x$break_positions()
          group.use$x <- x.divs
          label.x.pos <- tapply(X = group.use$x, INDEX = group.use[[colname]],
                                FUN = median) * x.max
          label.x.pos <- data.frame(group = names(x = label.x.pos), 
                                    label.x.pos)
          plot <- plot + geom_text(stat = "identity", 
                                   data = label.x.pos, aes_string(label = "group", 
                                                                  x = "label.x.pos"), y = y.max + y.max * 
                                     0.03 * 0.5, angle = angle, hjust = hjust, 
                                   size = size)
          plot <- suppressMessages(plot + coord_cartesian(ylim = c(0, 
                                                                   y.max + y.max * 0.002 * max(nchar(x = levels(x = group.use[[colname]]))) * 
                                                                     size), clip = "off"))
        }
      }
    }
    plot <- plot + theme(line = element_blank())
    plots[[i]] <- plot
  }
  if (combine) {
    plots <- CombinePlots(plots = plots)
  }
  return(plots)
}
```

2.  ***Load the required RData files that have previously been QC'd***

```{Load RData files that have previously been QC'd}
##Load the required TME and CSF libraries, these have been previously QC'd
set.seed(1)
file_names <- list.files(paste0(cell_line_directory, '/Individual Cell Line RData/'), full.names = T)
lapply(file_names, load, .GlobalEnv)

## Load combined datasets
set.seed(1)
file_names <- list.files(cell_line_directory, pattern = "GBM_*",full.names = T)
lapply(file_names[3], load, .GlobalEnv) ##Make sure you load the FILTERED GBM_ALL data - they are both named 'Bardy_10x' in R
rm(file_names)
```

3.  ***We will now subsample each seurat object to have equal numbers in both TME and CSF. Run Step 9 after generating the merged Seurat Object to create a new object with cells downsampled to contain 1400 cells across all cell lines.***

```{Subsample Seurat objects and Merge}
###We downsample either CSF or TME (GM) samples to contain the same amount of cells as the matching sample for each cell line. i.e. if SANTB00134_TME contains 2163 cells and SANTB00134_CSF contains 3000, downsample SANTB00134_CSF. 
## We won't be using the MiSeq data from SANTB00497B 
SANTB00134_CSF <- subset(SANTB00134_CSF, downsample = 2163)
SANTB00159_TME <- subset(SANTB00159_TME, downsample = 1078)
SANTB00448_CSF <- subset(SANTB00448_CSF, downsample = 2781)
SANTB00468_TME <- subset(SANTB00468_TME, downsample = 1043)
SANTB00469_TME <- subset(SANTB00469_TME, downsample = 2356)
SANTB00497_CSF <- subset(SANTB00497_CSF, downsample = 3293)
BAH1_CSF <- subset(BAH1_CSF, downsample = 749)
BAH1B_CSF <- subset(BAH1B_CSF, downsample = 864)
HW1_CSF <- subset(HW1_CSF, downsample = 1648)
MN1_TME <- subset(MN1_TME, downsample = 702)

##We now merge seurat objects. 
##We will begin with the two runs of BAH1. We add cells ids BAH1 for NovaSeq and BAH1B for Miseq. We first merge the two CSF and two TME (GM) samples
BAH1_CSF_merged <- merge(BAH1_CSF, BAH1B_CSF, add.cell.ids = c("BAH1_CSF", "BAH1B_CSF"))
BAH1_TME_merged <- merge(BAH1_TME, BAH1B_TME, add.cell.ids = c("BAH1_TME", "BAH1B_TME"))

##We next merge the two conditions of each cell line
##We do this to simplify merging all the cell lines together.
Seurat_111 <- merge(SANTB00111_CSF, y = SANTB00111_TME, add.cell.ids = c("111_CSF","111_TME"))
Seurat_134 <- merge(SANTB00134_CSF, y = SANTB00134_TME, add.cell.ids = c("134_CSF","134_TME"))
Seurat_159 <- merge(SANTB00159_CSF, y = SANTB00159_TME, add.cell.ids = c("159_CSF","159_TME"))
Seurat_497 <- merge(SANTB00497_CSF, y = SANTB00497_TME, add.cell.ids = c("497_CSF","497_TME"))
Seurat_BAH1 <- merge(BAH1_CSF_merged, y = BAH1_TME_merged)
Seurat_HW1 <- merge(HW1_CSF, y = HW1_TME, add.cell.ids = c("HW1_CSF","HW1_TME"))
Seurat_MN1 <- merge(MN1_CSF, y = MN1_TME, add.cell.ids = c("MN1_CSF","MN1_TME"))
Seurat_468 <- merge(SANTB00468_CSF, y = SANTB00468_TME, add.cell.ids = c("468_CSF","468_TME"))
Seurat_469 <- merge(SANTB00469_CSF, y = SANTB00469_TME, add.cell.ids = c("469_CSF","469_TME"))
Seurat_448 <- merge(SANTB00448_CSF, y = SANTB00448_TME, add.cell.ids = c("448_CSF","448_TME"))

##We now merge all the cell lines together. 
Bardy_10x <- merge(Seurat_111, y = c(Seurat_134, Seurat_159, Seurat_497, Seurat_BAH1, Seurat_468, Seurat_MN1, Seurat_HW1, Seurat_448, Seurat_469))
```

4.  ***Add new metadata to Bardy_10x Seurat Object.***

```{Add new metadata}
##We will now add a new column with combined PatientID_Condition
Bardy_10x$Condition_PatientID <- paste(Bardy_10x$PatientID, Bardy_10x$Condition, sep = "_")
##We rename the PatientID 'BAH1B' as 'BAH1'. This will help analyse both samples together.
Bardy_10x@meta.data$Condition_PatientID[which(Bardy_10x@meta.data$Condition_PatientID == "BAH1B_CSF")] <- "BAH1_CSF"
Bardy_10x@meta.data$Condition_PatientID[which(Bardy_10x@meta.data$Condition_PatientID == "BAH1B_TME")] <- "BAH1_TME"
##Add information regarding sequencing platforms.
Bardy_10x$Platform <- "EMPTY"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "SANTB00111")] <- "NextSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "SANTB00134")] <- "NextSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "SANTB00159")] <- "NextSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "SANTB00469")] <- "NovaSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "SANTB00468")] <- "NovaSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "SANTB00497")] <- "NovaSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "SANTB00448")] <- "NovaSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "HW1")] <- "NovaSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "MN1")] <- "NovaSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$PatientID == "BAH1")] <- "NovaSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$orig.ident == "BAH1B_TME")] <- "MiSeq"
Bardy_10x@meta.data$Platform[which(Bardy_10x@meta.data$orig.ident == "BAH1B_CSF")] <- "MiSeq"

##Run these lines AFTER step 7 (Optional)
Bardy_10x$Condition_Quadrant <- paste(Bardy_10x$Quadrant, Bardy_10x$Condition, sep = "_")
Bardy_10x$Condition_MESlike <- paste(Bardy_10x$MESlike, Bardy_10x$Condition, sep = "_")

##Save the Seurat Object
save(Bardy_10x, file = paste0(datadirectory, "~/RData/GBM_All.Rdata"))
```

5.  ***Normalise, scale and find variable features in the merged Seurat object.***

```{We now normalise and scale the Seurat object - Bardy_10x}
Bardy_10x <- NormalizeData(Bardy_10x, normalization.method = "LogNormalize")
Bardy_10x <- ScaleData(Bardy_10x, vars.to.regress = c("PatientID","Platform")) ##you can use the vars.to.regress to filter out any patient batch effects
Bardy_10x <- FindVariableFeatures(Bardy_10x, nfeatures = 2000)
Bardy_10x <- RunPCA(Bardy_10x, npcs = 100, features = VariableFeatures(Bardy_10x)) ##Compute 100 PCs to visualise the variance 

##Visualise the variance, we can then use this to determine which PCs contain the most variances
EP <- ElbowPlot(Bardy_10x, ndims = 100, reduction = "pca") + geom_vline(xintercept = 25, linetype = "dashed", col = "red", size = 1) 
EP
ggsave(EP, file = paste0(resultsdirectory, "ElbowPlot_100.pdf", sep = "/"), width = 6, height = 6)

##We perform non-linear non-linear dimensionality reduction - UMAPs
##We first find neighbours using the first 25 PCs and generate cell clusters. We next generate UMAP plots. 
Bardy_10x <- FindNeighbors(Bardy_10x, reduction = "pca", dims = 1:25)
Bardy_10x <- FindClusters(Bardy_10x, resolution = 0.05) ##original 0.05
Bardy_10x <- RunUMAP(Bardy_10x, reduction = "pca", dims = 1:25, n.components = 2L)
```

7.  ***We will now add some more metadata based on Neftel's MetaModules and CellCycle data. Repeat for downsampled 'GBM_700cells' Seurat object by replacing 'Bardy_10x' with 'GBM_700cells'. Double check the column names and object names.***

```{Add Neftel metamodule data}
##We will now go on to calculate a MES, AC, OPC and NPC-like score for each cell in the dataset based on the expression of genes provided by Neftel
## Load the Neftel gene expression signatures
signatures <- read.table(file = paste0(datadirectory, "/reference_sheets/IDHwt.GBM.MetaModules.tsv", sep = "/"), header = TRUE)

######First we convert features to a list format####
MESlike2_features <- as.character(signatures$MESlike2)
MESlike1_features <- as.character(signatures$MESlike1)
##For MESlike features, we extract the unique signatures from both MESlike1 and MESlike2. We then remove any NA values. 
MESlike_features <- unique(c(MESlike2_features, MESlike1_features))
MESlike_features <- MESlike_features[!is.na(MESlike_features)]
##Generate list of MES signatures. 
MESlike_features <- list(c(as.vector(MESlike_features)))
MESlike1_features <- list(c(as.vector(MESlike1_features)))
MESlike2_features <- list(c(as.vector(MESlike2_features)))

##Repeat the above process for AClike, NPClike and OPClike features.
AClike_features <- signatures$AClike
AClike_features <- AClike_features[!is.na(AClike_features)]
AClike_features <- list(c(as.vector(AClike_features)))

OPClike_features <- signatures$OPClike
OPClike_features <- OPClike_features[!is.na(OPClike_features)]
OPClike_features <- list(c(as.vector(OPClike_features)))

NPClike2_features <- as.character(signatures$NPClike2)
NPClike1_features <- as.character(signatures$NPClike1)
NPClike_features <- unique(c(NPClike2_features, NPClike1_features))
NPClike_features <- NPClike_features[!is.na(NPClike_features)]
NPClike_features <- list(c(NPClike_features))
NPClike1_features <- list(c(NPClike1_features))
NPClike2_features <- list(c(NPClike2_features))

## Calculate MESlike, AClike, OPClike and NPClike scores for each sample ####
Bardy_10x <- AddModuleScore(
  object = Bardy_10x,
  features = c(MESlike_features, AClike_features, OPClike_features, NPClike_features),
  name = c("MESlike", "AClike", "OPClike", "NPClike"),
  nbin = 30,
  ctrl = 100,
  seed = 1,
  search = TRUE
)

##Rename the columns in the metadata. DOUBLE CHECK the COLUMN NUMBERS. 
names(Bardy_10x@meta.data)[13:16] <- c("MESlike.Score", "AClike.Score", "OPClike.Score", "NPClike.Score")

###We now run some calculations before generating the Neftel_Quadrants. 
maxn <- function(n) function(x) order(x, decreasing = TRUE)[n] # a function that returns the position of n-th largest

## Calculate max scores for OPC-NPC vs AC-MES
##Here, the function assesses the  NPC and OPC-like score and takes the largest value of the two and creates a new column with the largest value. DOUBLE CHECK the COLUMN NUMBERS. 
Bardy_10x@meta.data$MaxScore_OPC.NPC <- apply(Bardy_10x@meta.data[, 15:16], 1, function(x)x[maxn(1)(x)])
Bardy_10x@meta.data$MaxScore_AC.MES <- apply(Bardy_10x@meta.data[, 13:14], 1, function(x)x[maxn(1)(x)])
## Calculate D1. 
## RATIONALE: If for a CELL, MaxScore_OPC.NPC is the value of the OPC score and MaxScore_AC.MES is the value of the AC score, and IF OPC score > AC score then D1 (MaxScore_OPC.NPC - MaxScore_AC.MES) would be > 0. The CELL would be more OPClike than AClike. IF OPC score < AC score then D1 (MaxScore_OPC.NPC - MaxScore_AC.MES) would be < 0. The CELL would be more AClike than OPClike.
Bardy_10x@meta.data$D1 <- with(Bardy_10x@meta.data, MaxScore_OPC.NPC - MaxScore_AC.MES)
## Classify D1 > 0 as OPC-NPC cells, and D1 < 0 as AC-MES cells
Bardy_10x@meta.data$combGroup1 <- c("EMPTY")
Bardy_10x@meta.data$combGroup1[Bardy_10x@meta.data$D1 > 0] <- "OPC_NPC"
Bardy_10x@meta.data$combGroup1[Bardy_10x@meta.data$D1 < 0] <- "AC_MES"

## Calculate max scores for AC-OPC vs MES-NPC
##Here, the function assesses the  AC and OPC-like score and takes the largest value of the two and creates a new column with the largest value. DOUBLE CHECK the COLUMN NUMBERS. 
Bardy_10x@meta.data$MaxScore_AC.OPC <- apply(Bardy_10x@meta.data[, 14:15], 1, function(x)x[maxn(1)(x)])
Bardy_10x@meta.data$MaxScore_MES.NPC <- apply(Bardy_10x@meta.data[, c(13,16)], 1, function(x)x[maxn(1)(x)])
## Calculate D2
## RATIONALE: If for a CELL, MaxScore_AC.OPC is the value of the OPC score and MaxScore_MES.NPC is the value of the MES score, and IF OPC score > MES score then D2 (MaxScore_AC.OPC - MaxScore_MES.NPC) would be > 0. The CELL would be more OPClike than MESlike. IF OPC score < AC score then D2 (MaxScore_AC.OPC - MaxScore_MES.NPC) would be < 0. The CELL would be more MESlike than OPClike.
Bardy_10x@meta.data$D2 <- with(Bardy_10x@meta.data, MaxScore_AC.OPC - MaxScore_MES.NPC)
## Classify D2 > 0 as AC-OPC cells, and D1 < 0 as MES-NPC cells
Bardy_10x@meta.data$combGroup2 <- c("EMPTY")
Bardy_10x@meta.data$combGroup2[Bardy_10x@meta.data$D2 > 0] <- "AC_OPC"
Bardy_10x@meta.data$combGroup2[Bardy_10x@meta.data$D2 < 0] <- "MES_NPC"

##We will now calculate a relative metamodule x and y score. 
##We want NPC and OPC-like cells to have a positive y-value and AC and MES-like cells to have a negative y-value.
##For cells that are classified as 'OPC_NPC' we log2 transform the difference between OPClike and NPClike scores.
##For cells that are classified as 'OPC_NPC' we (-)log2 transform the difference between OPClike and NPClike scores. A positive value will indicate OPC/NPC and a negative value AC/MES.
Bardy_10x@meta.data$rel.metamodule.y.score[Bardy_10x@meta.data$combGroup1 == "OPC_NPC"] <- with(Bardy_10x@meta.data[Bardy_10x@meta.data$combGroup1 == "OPC_NPC",], log2((abs(OPClike.Score - NPClike.Score)) + 1))
Bardy_10x@meta.data$rel.metamodule.y.score[Bardy_10x@meta.data$combGroup1 == "AC_MES"] <- with(Bardy_10x@meta.data[Bardy_10x@meta.data$combGroup1 == "AC_MES",], -log2((abs(AClike.Score - MESlike.Score)) + 1)) ## negative number for AC-MES

##We want NPC and MES-like cells to have a positive x-value and AC and OPC-like cells to have a negative y-value.
##For cells that are classified as 'AC_OPC' we -log2 transform the difference between OPClike and AClike scores.
##For cells that are classified as 'MES_NPC' we log2 transform the difference between NPClike and MESClike scores. A positive value will indicate MES/NPC and a negative value AC/OPC.
Bardy_10x@meta.data$rel.metamodule.x.score[Bardy_10x@meta.data$combGroup2 == "AC_OPC"] <- with(Bardy_10x@meta.data[Bardy_10x@meta.data$combGroup2 == "AC_OPC",], -log2((abs(AClike.Score - OPClike.Score)) + 1)) ## negative number for AC-OPC
Bardy_10x@meta.data$rel.metamodule.x.score[Bardy_10x@meta.data$combGroup2 == "MES_NPC"] <- with(Bardy_10x@meta.data[Bardy_10x@meta.data$combGroup2 == "MES_NPC",], log2((abs(MESlike.Score - NPClike.Score)) + 1))

## We can now classify cells into different cell states.
## Left-Top Quadrant: OPC-like - Negative x-value and Positive y-value.
## Right-Top Quadrant: NPC-like - Positive x-value and Positive y-value.
## Left-Bottom Quadrant: AC-like - Negative x-value and Negative y-value.
## Right-Bottom Quadrant: MES-like - Positive x-value and Negative y-value.

## Add new column in metadata with cell-state name.
Bardy_10x@meta.data$Quadrant <- c("EMPTY")
Bardy_10x@meta.data$Quadrant[Bardy_10x@meta.data$rel.metamodule.x.score < 0 & Bardy_10x@meta.data$rel.metamodule.y.score < 0] <- "AClike"
Bardy_10x@meta.data$Quadrant[Bardy_10x@meta.data$rel.metamodule.x.score < 0 & Bardy_10x@meta.data$rel.metamodule.y.score > 0] <- "OPClike"
Bardy_10x@meta.data$Quadrant[Bardy_10x@meta.data$rel.metamodule.x.score > 0 & Bardy_10x@meta.data$rel.metamodule.y.score > 0] <- "NPClike"
Bardy_10x@meta.data$Quadrant[Bardy_10x@meta.data$rel.metamodule.x.score > 0 & Bardy_10x@meta.data$rel.metamodule.y.score < 0] <- "MESlike"

##Calculate the number of cells in each quadrant; per patient, per condition, per condition_patient
cellstate_percondition_perpatient <- Bardy_10x@meta.data %>% group_by(Condition_PatientID, Quadrant) %>% tally()
write.csv(as.data.frame(cellstate_percondition_perpatient), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_cellstate_percondition_perpatient.csv"), quote = FALSE)

cellstate_percondition <- Bardy_10x@meta.data %>% group_by(Condition, Quadrant) %>% tally()
write.csv(as.data.frame(cellstate_percondition), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_cellstate_percondition.csv"), quote = FALSE)

cellstate_perpatient <- Bardy_10x@meta.data %>% group_by(PatientID, Quadrant) %>% tally()
write.csv(as.data.frame(cellstate_perpatient), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_cellstate_perpatient.csv"), quote = FALSE)

percondition_perpatient <- Bardy_10x@meta.data %>% group_by(PatientID, Condition) %>% tally()
write.csv(as.data.frame(percondition_perpatient), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_percondition_perpatient.csv"), quote = FALSE)

####We now Calculate MESlike1,2 and NPClike1,2 scores for each sample #####
Bardy_10x <- AddModuleScore(
  object = Bardy_10x,
  features = c(MESlike1_features, MESlike2_features, NPClike1_features, NPClike2_features),
  name = c("MESlike1", "MESlike2", "NPClike1", "NPClike2"),
  nbin = 30,
  ctrl = 100,
  seed = 1,
  search = TRUE
)

##Rename the columns in the metadata. DOUBLE CHECK the COLUMN NUMBERS.
names(Bardy_10x@meta.data)[28:31] <- c("MESlike1.Score", "MESlike2.Score", "NPClike1.Score", "NPClike2.Score")

##We create new metadata columns to classify cells as MESlike1, 2 or not MESlike. 
##We do this ONLY for cells that we classified as MESlike above. 
Bardy_10x$MESlike <- ifelse(Bardy_10x$MESlike1.Score > Bardy_10x$MESlike2.Score & Bardy_10x$Quadrant == "MESlike", "MESlike1", ifelse(Bardy_10x$MESlike1.Score < Bardy_10x$MESlike2.Score & Bardy_10x$Quadrant == "MESlike", "MESlike2", "notMESlike"))
unique(Bardy_10x$MESlike)

##We create new metadata columns to classify cells as NPClike1, 2 or not NPClike. ####
##We do this ONLY for cells that we classified as NPClike above. 
Bardy_10x$NPClike <- ifelse(Bardy_10x$NPClike1.Score > Bardy_10x$NPClike2.Score & Bardy_10x$Quadrant == "NPClike", "NPClike1", 
       ifelse(Bardy_10x$NPClike1.Score < Bardy_10x$NPClike2.Score & Bardy_10x$Quadrant == "NPClike", "NPClike2", "notNPClike"))
unique(Bardy_10x$NPClike)

MESlike_percondition_perpatient <- Bardy_10x@meta.data %>% group_by(Condition, PatientID ,MESlike) %>% tally()
write.csv(as.data.frame(MESlike_percondition_perpatient), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_MESlike_percondition_perpatient.csv"), quote = FALSE)

MESlike_percondition_quiescence <- Bardy_10x@meta.data %>% group_by(Condition, Quiescence, MESlike) %>% tally()
write.csv(as.data.frame(MESlike_percondition_quiescence), file = paste0(resultsdirectory, "/GBM_All_sheets/MESlike_percondition_quiescence.csv"), quote = FALSE)

MESlike_percondition_cellcycle <- Bardy_10x@meta.data %>% group_by(Condition, Cell_Cycle, MESlike) %>% tally()
write.csv(as.data.frame(MESlike_percondition_cellcycle), file = paste0(resultsdirectory, "/GBM_All_sheets/MESlike_percondition_cellcycle.csv"), quote = FALSE)
```

7b. ***We will also calculate proliferation and quiescence scores. Repeat for downsampled 'GBM_700cells'*** ***Seurat object by replacing 'Bardy_10x' with 'GBM_700cells'. Double check the column names and object names.***

```{Calculate Proliferation and Quiescence scores}
##We will now do the same for cycling cells####
##Load cellcycle signatures. The signatures were obtained from Tirosh et al, 2016. 
cellcycle <- read.table(file = paste0(datadirectory, "/reference_sheets/cellcycle_tirosh.tsv"), header = TRUE)

######First we convert features to a list format####
G1S_features <- as.character(cellcycle$G1.S)
##Remove any NA values.
G1S_features <- G1S_features[!is.na(G1S_features)]
G1S_features <- list(c(as.vector(G1S_features)))

G2M_features <- as.character(cellcycle$G2.M)
G2M_features <- G2M_features[!is.na(G2M_features)]
G2M_features <- list(c(G2M_features))

## Calculate G1S and G2M scores for each sample
Bardy_10x <- AddModuleScore(
  object = Bardy_10x,
  features = c(G1S_features, G2M_features),
  name = c("G1S", "G2M"),
  nbin = 30,
  ctrl = 100,
  seed = 1,
  search = TRUE
)
##Rename the columns in the metadata. DOUBLE CHECK the COLUMN NUMBERS. 
names(Bardy_10x@meta.data)[34:35] <- c("G1S.Score", "G2M.Score")

##We calculate a proliferations score based on the average of the G1S and G2M scores.
Bardy_10x$Proliferation.Score <- (Bardy_10x$G1S.Score + Bardy_10x$G2M.Score)/2
##Classify the cells as Cycling or NonCycling
Bardy_10x$Cell_Cycle <- "NULL"
Bardy_10x$Cell_Cycle[Bardy_10x@meta.data$Proliferation.Score < 0] <- "NonCycling"
Bardy_10x$Cell_Cycle[Bardy_10x@meta.data$Proliferation.Score > 0] <- "Cycling"
unique(Bardy_10x$Cell_Cycle)

##Create a combined CellCycle_Condition column. 
Bardy_10x$CellCycle_Condition <- paste(Bardy_10x$Cell_Cycle, Bardy_10x$Condition, sep = "_")

###Count cycling and non-cycling cells; per quadrant, per condition####
cellstate_cellcycle <- Bardy_10x@meta.data %>% group_by(Cell_Cycle, Quadrant) %>% tally()
write.csv(as.data.frame(cellstate_cellcycle), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_cellstate_cellcycle.csv"), quote = FALSE)

cellstate_cellcycle_condition <- Bardy_10x@meta.data %>% group_by(CellCycle_Condition, Quadrant) %>% tally()
write.csv(as.data.frame(cellstate_cellcycle_condition), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_cellstate_cellcycle_condition.csv"), quote = FALSE)

##OPTIONAL: We now calculate a cell cycle difference score as in https://satijalab.org/seurat/archive/v2.4/cell_cycle_vignette.html this will help us regress out differences in the 'cycling phase' of cycling cells whilst maintaining differences between cycling and non-cycling cells. 
##Bardy_10x$CellCycleDifference.Score <- Bardy_10x$G1S.Score - Bardy_10x$G2M.Score

## We will now do the same for quiescent cells #####
## Load cellcycle signatures. The signatures were obtained from Atkins et al, 2019. 
quiescence_atkins <- read.table(file = paste0(datadirectory, "/reference_sheets/top50quiescent_atkins.txt"), header = TRUE)

######First we convert features to a list format####
Quiescent_features <- as.character(quiescence_atkins$Genes)
Quiescent_features <- Quiescent_features[!is.na(Quiescent_features)]
Quiescent_features <- list(c(as.vector(Quiescent_features)))

## Calculate the Quiescence score for each cell
Bardy_10x <- AddModuleScore(
  object = Bardy_10x,
  features = c(Quiescent_features),
  name = c("Quiescent.Score"),
  nbin = 30,
  ctrl = 100,
  seed = 1,
  search = TRUE
)

##Rename the columns in the metadata. DOUBLE CHECK the COLUMN NUMBERS. 
names(Bardy_10x@meta.data)[40] <- c("Quiescent.Score")

##We classify cells as Quiescent or NonQuiescent. 
Bardy_10x$Quiescence <- "NULL"
Bardy_10x$Quiescence[Bardy_10x@meta.data$Quiescent.Score < 0] <- "NonQuiescent"
Bardy_10x$Quiescence[Bardy_10x@meta.data$Quiescent.Score > 0] <- "Quiescent"

###Count quiescent and non-quiescent cells; per quadrant, per condition####
cellstate_quiescence_condition <- Bardy_10x@meta.data %>% group_by(Quiescence, Condition, Quadrant) %>% tally()
write.csv(as.data.frame(cellstate_quiescence_condition), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_cellstate_quiescence_condition.csv"), quote = FALSE)

cellstate_quiescence_condition_patient <- Bardy_10x@meta.data %>% group_by(Quiescence, Condition, Quadrant, PatientID) %>% tally()
write.csv(as.data.frame(cellstate_quiescence_condition_patient), file = paste0(resultsdirectory, "/GBM_All_sheets/GBM_cellstate_quiescence_condition_patient.csv"), quote = FALSE)

##Save MetaData and Seurat Object.
write.csv(Bardy_10x@meta.data, file = paste0(datadirectory,"/RData/metadata sheets/GBM_MetaData.csv"))
save(Bardy_10x, file = paste0("/RData/GBM_All.Rdata"))
```

8.  ***OPTIONAL. We will also calculate module scores based on the TCGA dataset. Repeat for downsampled GBM 700 cells Seurat object by replacing Bardy 10x with GBM 700cells. Double check the column names and object names.***

```{OPTIONAL. Calculate TCGA module scores and stem cell scores}
##We will now go on to calculate a MES, AC, OPC and NPC-like score for each cell in the dataset based on the expression of genes provided by Neftel
## Load the Neftel gene expression signatures
TCGA_signatures <- read.table(file = paste0(datadirectory, "/reference_sheets/TCGA.Verhaak.GBM.txt", sep = ""), header = TRUE)

######First we convert features to a list format####
TCGA_MES <- TCGA_signatures$Mesenchymal
TCGA_CL <- TCGA_signatures$Classical
TCGA_PN <- TCGA_signatures$Proneural

####OPTIONAL: Update Gene Symbols ####
GeneSymbolThesarus(
  symbols = c(TCGA_PN, TCGA_MES, TCGA_CL),
  timeout = 10,
  several.ok = FALSE,
  search.types = c("alias_symbol", "prev_symbol"),
  verbose = TRUE
)

## Calculate Mesenchymal, Classical, Proneural scores for each sample ####
TCGA_MES <- list(c(as.vector(TCGA_MES)))
TCGA_CL <- list(c(as.vector(TCGA_CL)))
TCGA_PN <- list(c(as.vector(TCGA_PN)))

##Calculate module scores for Mesenchymal, Classical and Proneural subtypes.
Bardy_10x <- AddModuleScore(
  object = Bardy_10x,
  features = c(TCGA_MES,TCGA_CL,TCGA_PN),
  name = c("Mesenchymal", "Classical", "Proneural"),
  nbin = 30,
  ctrl = 100,
  seed = 1,
  search = TRUE
)
##Rename column names. DOUBLE CHECK COLUMN NUMBERS. 
names(Bardy_10x@meta.data)[42:44] <- c("TCGA_Mesenchymal", "TCGA_Classical", "TCGA_Proneural")

###We now run some calculations before generating the Neftel_Quadrants. 
maxn <- function(n) function(x) order(x, decreasing = TRUE)[n] # a function that returns the position of n-th largest

## Calculate max scores for OPC-NPC vs AC-MES
##Here, the function assess the  NPC and OPC-like score and takes the largest value of the two and creates a new column with the largest value. 
Bardy_10x@meta.data$MaxScore_MES.CL <- apply(Bardy_10x@meta.data[,42:43], 1, function(x)x[maxn(1)(x)]) ## value of the largest score
Bardy_10x@meta.data$MaxScore_CL.PN <- apply(Bardy_10x@meta.data[, 43:44], 1, function(x)x[maxn(1)(x)])
Bardy_10x@meta.data$MaxScore_MES.PN <- apply(Bardy_10x@meta.data[, 42:44], 1, function(x)x[maxn(1)(x)])

##We will now assign a subtype to each cell. 
Bardy_10x@meta.data$TCGA <- c("EMPTY")
Bardy_10x@meta.data$TCGA<- if_else(Bardy_10x@meta.data$TCGA_Mesenchymal == Bardy_10x@meta.data$MaxScore_MES.PN, "Mesenchymal", "Proneural")
Bardy_10x@meta.data$TCGA<- if_else(Bardy_10x@meta.data$TCGA_Mesenchymal == Bardy_10x@meta.data$MaxScore_MES.CL, "Mesenchymal", "Classical")
Bardy_10x@meta.data$TCGA<- if_else(Bardy_10x@meta.data$TCGA_Mesenchymal == Bardy_10x@meta.data$MaxScore_CL.PN, "Classical", "Proneural")
Bardy_10x@meta.data$TCGA[Bardy_10x@meta.data$TCGA_Mesenchymal >= 0 & Bardy_10x@meta.data$TCGA_Classical < 0 & Bardy_10x@meta.data$TCGA_Proneural < 0] <- "Mesenchymal"
Bardy_10x@meta.data$TCGA[Bardy_10x@meta.data$TCGA_Mesenchymal < 0 & Bardy_10x@meta.data$TCGA_Classical >= 0 & Bardy_10x@meta.data$TCGA_Proneural < 0] <- "Classical"
Bardy_10x@meta.data$TCGA[Bardy_10x@meta.data$TCGA_Mesenchymal < 0 & Bardy_10x@meta.data$TCGA_Classical < 0 & Bardy_10x@meta.data$TCGA_Proneural >= 0] <- "Proneural"

##Correlation between Neftel and TCGA subtypes. 
cor(Bardy_10x$MESlike.Score,  Bardy_10x$TCGA_Mesenchymal)
cor(Bardy_10x$AClike.Score,  Bardy_10x$TCGA_Classical)
cor(Bardy_10x$NPClike.Score,  Bardy_10x$TCGA_Proneural)
cor(Bardy_10x$OPClike.Score,  Bardy_10x$TCGA_Proneural)

##We will now do the same for stem cell markers#####
##The CSV contains stem-cells genes classified by Lathia and Richards et al, 2021
stem_cell <- read.csv(file = paste0(datadirectory, "/reference_sheets/Stemcell.Markers.csv"), header = TRUE)

##We generate signature lists as before.
Lathia_GSC <- as.character(stem_cell[1:24,1])
Lathia_GSC <- list(c(as.vector(Lathia_GSC)))
Richards_Dev_GSC <- as.character(stem_cell[1:100,3])
Richards_Dev_GSC <- list(c(as.vector(Richards_Dev_GSC)))
Richards_Inj_GSC <- as.character(stem_cell[1:100,4])
Richards_Inj_GSC <- list(c(as.vector(Richards_Inj_GSC)))
Tirosh_GSC <- as.character(stem_cell[1:62,5])
Tirosh_GSC <- list(c(as.vector(Tirosh_GSC)))

## Calculate GSC scores for each sample
Bardy_10x <- AddModuleScore(
  object = Bardy_10x,
  features = c(Lathia_GSC, Richards_Dev_GSC,Richards_Inj_GSC,Tirosh_GSC),
  name = c("Lathia_GSC", "Richards_Dev_GSC","Richards_Inj_GSC","Tirosh_GSC"),
  nbin = 30,
  ctrl = 100,
  seed = 1,
  search = TRUE
)

##Rename columns. DOUBLE CHECK COLUMN NUMBERS.
names(Bardy_10x@meta.data)[50:52] <- c("Lathia_GSC.Score", "Richards_Dev_GSC.Score", "Richards_Inj_GSC.Score")

Bardy_10x@meta.data$Lathia_GSC <- c("EMPTY")
Bardy_10x@meta.data$Lathia_GSC[Bardy_10x@meta.data$Lathia_GSC.Score >= 0] <- "GSC"
Bardy_10x@meta.data$Lathia_GSC[Bardy_10x@meta.data$Lathia_GSC.Score < 0] <- "non-GSC"

Bardy_10x@meta.data$Richards_GSC <- c("EMPTY")
Bardy_10x@meta.data$Richards_GSC[Bardy_10x@meta.data$Richards_Dev_GSC.Score >= 0 & Bardy_10x@meta.data$Richards_Inj_GSC.Score >= 0] <- "GSC"
Bardy_10x@meta.data$Richards_GSC[Bardy_10x@meta.data$Richards_Dev_GSC.Score < 0 & Bardy_10x@meta.data$Richards_Inj_GSC.Score < 0] <- "non-GSC"
Bardy_10x@meta.data$Richards_GSC[Bardy_10x@meta.data$Richards_Dev_GSC.Score >= 0 & Bardy_10x@meta.data$Richards_Inj_GSC.Score < 0] <- "Dev-GSC"
Bardy_10x@meta.data$Richards_GSC[Bardy_10x@meta.data$Richards_Dev_GSC.Score < 0 & Bardy_10x@meta.data$Richards_Inj_GSC.Score >= 0] <- "Inj-GSC"

Bardy_10x@meta.data$Tirosh_GSC <- c("EMPTY")
Bardy_10x@meta.data$Tirosh_GSC[Bardy_10x@meta.data$Tirosh_GSC.Score >= 0] <- "GSC"
Bardy_10x@meta.data$Tirosh_GSC[Bardy_10x@meta.data$Tirosh_GSC.Score < 0] <- "non-GSC"

##Save MetaData and Seurat Object
write.csv(Bardy_10x@meta.data, file = paste0(datadirectory, "~/RData/metadata sheets/GBM_MetaData.csv"))
save(Bardy_10x, file = paste0(datadirectory, "~/RData/GBM_All.Rdata"))
```

9.  ***We will also create a second Seurat Object and subsample to have equal numbers of cells across all cell lines. This is to help with differential expression analyses so that there is not bias from any cell line. RECALCULATE MODULE SCORES for NEFTEL, CELLCYCLE, QUIESCENCE, STEMCELLS and TCGA. Replace 'Bardy_10x' with 'GBM_700cells'.***

```{Subsample Seurat objects}
##Set Identity before subsetting the Seurat Object. 
Idents(Bardy_10x) <- "Condition_PatientID"
## We randomly subset and downsample each cell line. We downsample to 700 because MN1 has the lowest number of cells i.e. 702. ####
SANTB00111_CSF <- subset(Bardy_10x, idents = "SANTB00111_CSF")
Idents(SANTB00111_CSF) <- "PatientID"
SANTB00111_CSF <- subset(SANTB00111_CSF, downsample = 700)
SANTB00111_TME <- subset(Bardy_10x, idents = "SANTB00111_TME")
Idents(SANTB00111_TME) <- "PatientID"
SANTB00111_TME <- subset(SANTB00111_TME, downsample = 700)

SANTB00134_CSF <- subset(Bardy_10x, idents = "SANTB00134_CSF")
Idents(SANTB00134_CSF) <- "PatientID"
SANTB00134_CSF <- subset(SANTB00134_CSF, downsample = 700)
SANTB00134_TME <- subset(Bardy_10x, idents = "SANTB00134_TME")
Idents(SANTB00134_TME) <- "PatientID"
SANTB00134_TME <- subset(SANTB00134_TME, downsample = 700)

SANTB00159_CSF <- subset(Bardy_10x, idents = "SANTB00159_CSF")
Idents(SANTB00159_CSF) <- "PatientID"
SANTB00159_CSF <- subset(SANTB00159_CSF, downsample = 700)
SANTB00159_TME <- subset(Bardy_10x, idents = "SANTB00159_TME")
Idents(SANTB00159_TME) <- "PatientID"
SANTB00159_TME <- subset(SANTB00159_TME, downsample = 700)

SANTB00448_CSF <- subset(Bardy_10x, idents = "SANTB00448_CSF")
Idents(SANTB00448_CSF) <- "PatientID"
SANTB00448_CSF <- subset(SANTB00448_CSF, downsample = 700)
SANTB00448_TME <- subset(Bardy_10x, idents = "SANTB00448_TME")
Idents(SANTB00448_TME) <- "PatientID"
SANTB00448_TME <- subset(SANTB00448_TME, downsample = 700)

SANTB00468_CSF <- subset(Bardy_10x, idents = "SANTB00468_CSF")
Idents(SANTB00468_CSF) <- "PatientID"
SANTB00468_CSF <- subset(SANTB00468_CSF, downsample = 700)
SANTB00468_TME <- subset(Bardy_10x, idents = "SANTB00468_TME")
Idents(SANTB00468_TME) <- "PatientID"
SANTB00468_TME <- subset(SANTB00468_TME, downsample = 700)

SANTB00469_CSF <- subset(Bardy_10x, idents = "SANTB00469_CSF")
Idents(SANTB00469_CSF) <- "PatientID"
SANTB00469_CSF <- subset(SANTB00469_CSF, downsample = 700)
SANTB00469_TME <- subset(Bardy_10x, idents = "SANTB00469_TME")
Idents(SANTB00469_TME) <- "PatientID"
SANTB00469_TME <- subset(SANTB00469_TME, downsample = 700)

SANTB00497_CSF <- subset(Bardy_10x, idents = "SANTB00497_CSF")
Idents(SANTB00497_CSF) <- "PatientID"
SANTB00497_CSF <- subset(SANTB00497_CSF, downsample = 700)
SANTB00497_TME <- subset(Bardy_10x, idents = "SANTB00497_TME")
Idents(SANTB00497_TME) <- "PatientID"
SANTB00497_TME <- subset(SANTB00497_TME, downsample = 700)

HW1_CSF <- subset(Bardy_10x, idents = "HW1_CSF")
Idents(HW1_CSF) <- "PatientID"
HW1_CSF <- subset(HW1_CSF, downsample = 700)
HW1_TME <- subset(Bardy_10x, idents = "HW1_TME")
Idents(HW1_TME) <- "PatientID"
HW1_TME <- subset(HW1_TME, downsample = 700)

MN1_CSF <- subset(Bardy_10x, idents = "MN1_CSF")
Idents(MN1_CSF) <- "PatientID"
MN1_CSF <- subset(MN1_CSF, downsample = 700)
MN1_TME <- subset(Bardy_10x, idents = "MN1_TME")
Idents(MN1_TME) <- "PatientID"
MN1_TME <- subset(MN1_TME, downsample = 700)

Idents(Bardy_10x) <- "orig.ident"
BAH1_CSF <- subset(Bardy_10x, idents = "BAH1_CSF")
Idents(BAH1_CSF) <- "PatientID"
BAH1_CSF <- subset(BAH1_CSF, downsample = 350)
BAH1_TME <- subset(Bardy_10x, idents = "BAH1_TME")
Idents(BAH1_TME) <- "PatientID"
BAH1_TME <- subset(BAH1_TME, downsample = 350)

BAH1B_CSF <- subset(Bardy_10x, idents = "BAH1B_CSF")
Idents(BAH1B_CSF) <- "PatientID"
BAH1B_CSF <- subset(BAH1B_CSF, downsample = 350)
BAH1B_TME <- subset(Bardy_10x, idents = "BAH1B_TME")
Idents(BAH1B_TME) <- "PatientID"
BAH1B_TME <- subset(BAH1B_TME, downsample = 350)

###We first merge CSF and TME of BAH1 and BAH1B####
BAH1_CSF_merged <- merge(BAH1_CSF, BAH1B_CSF)
BAH1_TME_merged <- merge(BAH1_TME, BAH1B_TME)

##We now merge both conditions into one Seurat object per cell line
Seurat_111 <- merge(SANTB00111_CSF, y = SANTB00111_TME)
##save(Seurat_111, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_111_700cells_percondition.Rdata"))

Seurat_134 <- merge(SANTB00134_CSF, y = SANTB00134_TME)
##save(Seurat_134, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_134_700cells_percondition.Rdata"))

Seurat_159 <- merge(SANTB00159_CSF, y = SANTB00159_TME)
##save(Seurat_159, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_159_700cells_percondition_1.Rdata"))

Seurat_497 <- merge(SANTB00497_CSF, y = SANTB00497_TME)
##save(Seurat_497, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_497_700cells_percondition.Rdata"))

Seurat_BAH1 <- merge(BAH1_CSF_merged, y = BAH1_TME_merged)
##save(Seurat_BAH1, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_BAH1_700cells_percondition.Rdata"))

Seurat_HW1 <- merge(HW1_CSF, y = HW1_TME)
#save(Seurat_HW1, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_HW1_700cells_percondition.Rdata"))

Seurat_MN1 <- merge(MN1_CSF, y = MN1_TME)
##save(Seurat_MN1, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_MN1_700cells_percondition.Rdata"))

Seurat_468 <- merge(SANTB00468_CSF, y = SANTB00468_TME)
##save(Seurat_468, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_468_700cells_percondition.Rdata"))

Seurat_469 <- merge(SANTB00469_CSF, y = SANTB00469_TME)
##save(Seurat_469, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_469_700cells_percondition.Rdata"))

Seurat_448 <- merge(SANTB00448_CSF, y = SANTB00448_TME)
##save(Seurat_448, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/Seurat_448_700cells_percondition.Rdata"))

##We make a single seurat object 
GBM_700cells <- merge(Seurat_111, y = c(Seurat_134, Seurat_159, Seurat_497, Seurat_BAH1, Seurat_468, Seurat_MN1, Seurat_HW1, Seurat_448, Seurat_469))

##We rename BAH1B to BAH1. 
GBM_700cells@meta.data$PatientID[which(GBM_700cells@meta.data$PatientID == "BAH1B")] <- "BAH1"
GBM_700cells@meta.data$Condition_PatientID[which(GBM_700cells@meta.data$Condition_PatientID == "BAH1B_CSF")] <- "BAH1_CSF"
GBM_700cells@meta.data$Condition_PatientID[which(GBM_700cells@meta.data$Condition_PatientID == "BAH1B_TME")] <- "BAH1_TME"

save(GBM_700cells, file = paste(cell_line_directory, "/RData/GBM_Downsampled.Rdata"))
```

10. ***We scale and normalise the 'GBM_700cells' seurat object***

```{Scale, Normalise and non-linear dimensionality reduction}
##We now scale and NormalizeData
GBM_700cells <- NormalizeData(GBM_700cells, normalization.method = "LogNormalize")
GBM_700cells <- FindVariableFeatures(GBM_700cells, nfeatures = 2000)
GBM_700cells <- ScaleData(GBM_700cells, vars.to.regress = "PatientID") ##you can use the vars.to.regress to filter out any patient batch effects
GBM_700cells <- RunPCA(GBM_700cells, npcs = 100, features = VariableFeatures(GBM_700cells)) ##Compute 100 PCs 

##Visualise the variance, we can then use this to determine which PCs contain the most variances
EP <- ElbowPlot(GBM_700cells, ndims = 100, reduction = "pca") + geom_vline(xintercept = 25, linetype = "dashed", col = "red", size = 1) 
EP
ggsave(EP, file = paste(resultsdirectory, "GBM_700cells_ElbowPlot_100.pdf", sep = "/"), width = 6, height = 6)

##We perform non-linear non-linear dimensionality reduction - UMAPs
##We first find neighbours using the first 25 PCs and generate cell clusters. We next generate UMAP plots. 
GBM_700cells <- FindNeighbors(GBM_700cells, reduction = "pca", dims = 1:25)
GBM_700cells <- FindClusters(GBM_700cells, resolution = 0.05) ##original 0.05
GBM_700cells <- RunUMAP(GBM_700cells, reduction = "pca", dims = 1:25, n.components = 2L)

save(GBM_700cells, file = paste(datadirectory, "/RData/GBM_Downsampled.Rdata"))
```

11a. ***Differential expression - 'GBM_700cells*****'*. This is to generate volcano plots.***

```{Perform DE for all cells CSF v GM}
#### Perform differential gene expression for all cells to see if there are any differences.####
##We first set the identity of the Seurat Object. 
Idents(GBM_700cells) <- "Condition"
##We want to detect genes that are significantly expressed in at least 30 percent of the cells with a difference of at least 5 percent between the two groups. 
CSF_Markers <- FindMarkers(GBM_700cells, ident.1 = "CSF", ident.2 = "TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05) 
##For GSEA we do a differential expression with default paramaters. 
CSF_Markers <- FindMarkers(GBM_700cells, ident.1 = "CSF", ident.2 = "TME", logfc.threshold = 0)

##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers <- CSF_Markers[order(-CSF_Markers$avg_log2FC, CSF_Markers$p_val_adj),]

write.csv(CSF_Markers, file = paste0(resultsdirectory, "/Differential Expression/GSEA_differentialexpression-all.csv"))
##CSF_Markers <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/GSEA_differentialexpression-all.csv"))

CSF_Features <- rownames(CSF_Markers[1:20,])
TME_Features <- rownames(CSF_Markers[3566:3585,])

DP <- DotPlot(GBM_700cells, features = c(CSF_Features,TME_Features), group.by = "Condition", scale = F) +
  theme(axis.text.x = element_text(size = 22, face = "italic", angle = 90, hjust = 1), 
        axis.text.y = element_text(size = 22), axis.title.x = element_blank(), axis.title.y = element_blank(),
        legend.position = "right", legend.text.align = 0, legend.text = element_text(size =20), 
        axis.ticks.x = element_line(size = 0.5), axis.ticks.y = element_line(size = 0.5),
        panel.border = element_rect(fill = NA, colour = "black", size = 0.5)) +
  scale_colour_gradient2(low = "blue", mid = "deepskyblue", high = "red", limits= c(0, 4), na.value = "white") +
  scale_radius(limits = c(0,100), breaks = c(0, 25, 50, 75, 100), range = c(0,9))
DP
ggsave(DP, filename = paste0(resultsdirectory, "/plots/Differential expression/GBM_700cells_DGECondition_Legend_Gradient_.pdf"), height = 3, width = 12, dpi = 300, useDingbats = FALSE)

Markers_sub <- CSF_Markers[c(1:20,3566:3585),]
Markers_sub$Condition <- "NA"
Markers_sub[1:20,11] <- "CSF"
Markers_sub[21:40,11] <- "GM"

DP <- ggplot(Markers_sub, aes(Condition, pct.1))  +
  geom_point(aes(size = pct.1, fill = avg_log2FC), alpha = 0.5, shape = 21) + 
  scale_size_continuous(limits = c(0.000001, 100), range = c(1,17), breaks = c(1,10,50,75)) +
  scale_size() +
  theme_minimal() +
  labs(y=expression('-Log'[10]*' P'[adj]), x=expression('Log'[2]*' fold change')) +
  scale_color_manual(values = c("red","grey27","red")) + 
  theme(legend.position = "none", legend.text = element_text(size = 16), legend.justification = "center",axis.text.x = element_text(size = 16, angle = 90), axis.text.y = element_text(size = 16),axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16), panel.border = element_rect(fill=NA, colour = "black", size=1))
DP
```

11b.
```{Perform DE for individual cell lines}
#### Perform differential gene expression for all cells including 448 to see if there are any differences. 
Idents(GBM_700cells) <- "Condition_PatientID"

CSF_Markers_111 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00111_CSF", ident.2 = "SANTB00111_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_111 <- CSF_Markers_111[order(-CSF_Markers_111$avg_log2FC, CSF_Markers_111$p_val_adj),]
#write.csv(CSF_Markers_111, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_111_700cells_percondition_downsample.csv"))
CSF_Markers_111 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_111_700cells_percondition_downsample.csv"))

CSF_Markers_134 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00134_CSF", ident.2 = "SANTB00134_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_134 <- CSF_Markers_134[order(-CSF_Markers_134$avg_log2FC, CSF_Markers_134$p_val_adj),]
##write.csv(CSF_Markers_134, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_134_700cells_percondition_downsample.csv"))
CSF_Markers_134 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_134_700cells_percondition_downsample.csv"))

CSF_Markers_159 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00159_CSF", ident.2 = "SANTB00159_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_159 <- CSF_Markers_159[order(-CSF_Markers_159$avg_log2FC, CSF_Markers_159$p_val_adj),]
##write.csv(CSF_Markers_159, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_159_700cells_percondition_downsample.csv"))
CSF_Markers_159 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_159_700cells_percondition_downsample.csv"))

CSF_Markers_448 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00448_CSF", ident.2 = "SANTB00448_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_448 <- CSF_Markers_448[order(-CSF_Markers_448$avg_log2FC, CSF_Markers_448$p_val_adj),]
##write.csv(CSF_Markers_448, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_448_700cells_percondition_downsample.csv"))
CSF_Markers_448 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_448_700cells_percondition_downsample.csv"))

CSF_Markers_468 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00468_CSF", ident.2 = "SANTB00468_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_468 <- CSF_Markers_468[order(-CSF_Markers_468$avg_log2FC, CSF_Markers_468$p_val_adj),]
##write.csv(CSF_Markers_468, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_468_700cells_percondition_downsample.csv"))
CSF_Markers_468 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_468_700cells_percondition_downsample.csv"))

CSF_Markers_469 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00469_CSF", ident.2 = "SANTB00469_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_469 <- CSF_Markers_469[order(-CSF_Markers_469$avg_log2FC, CSF_Markers_469$p_val_adj),]
##write.csv(CSF_Markers_469, file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/Downsampled RData for DE/CSF_Markers_469_700cells_percondition_downsample.csv"))
CSF_Markers_469 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_469_700cells_percondition_downsample.csv"))

CSF_Markers_497 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00497_CSF", ident.2 = "SANTB00497_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_497 <- CSF_Markers_497[order(-CSF_Markers_497$avg_log2FC, CSF_Markers_497$p_val_adj),]
##write.csv(CSF_Markers_497, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_497_700cells_percondition_downsample.csv"))
CSF_Markers_497 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_497_700cells_percondition_downsample.csv"))

CSF_Markers_BAH1 <- FindMarkers(GBM_700cells, ident.1 = "BAH1_CSF", ident.2 = "BAH1_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_BAH1 <- CSF_Markers_BAH1[order(-CSF_Markers_BAH1$avg_log2FC, CSF_Markers_BAH1$p_val_adj),]
##write.csv(CSF_Markers_BAH1, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_BAH1_700cells_percondition_downsample.csv"))
CSF_Markers_BAH1 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_BAH1_700cells_percondition_downsample.csv"))

CSF_Markers_HW1 <- FindMarkers(GBM_700cells, ident.1 = "HW1_CSF", ident.2 = "HW1_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_HW1 <- CSF_Markers_HW1[order(-CSF_Markers_HW1$avg_log2FC, CSF_Markers_HW1$p_val_adj),]
##write.csv(CSF_Markers_HW1, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_HW1_700cells_percondition_downsample.csv"))
CSF_Markers_HW1 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_HW1_700cells_percondition_downsample.csv"))

CSF_Markers_MN1 <- FindMarkers(GBM_700cells, ident.1 = "MN1_CSF", ident.2 = "MN1_TME", min.pct = 0.3, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_MN1 <- CSF_Markers_MN1[order(-CSF_Markers_MN1$avg_log2FC, CSF_Markers_MN1$p_val_adj),]
##write.csv(CSF_Markers_MN1, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_MN1_700cells_percondition_downsample.csv"))
CSF_Markers_MN1 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_MN1_700cells_percondition_downsample.csv"))
```

11c. ***Using the markers from DE to conduct a hierarchical clustering of the cell lines. We change min.pct to 10 to include more genes for hierarchical clustering.***

```{Hierarchical Clustering}
Idents(GBM_700cells) <- "Condition_PatientID"
CSF_Markers_111 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00111_CSF", ident.2 = "SANTB00111_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_111 <- CSF_Markers_111[order(-CSF_Markers_111$avg_log2FC, CSF_Markers_111$p_val_adj),]
##write.csv(CSF_Markers_111, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_111_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_111 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_111_700cells_percondition_downsample_minpct0.1.csv"))


CSF_Markers_134 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00134_CSF", ident.2 = "SANTB00134_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_134 <- CSF_Markers_134[order(-CSF_Markers_134$avg_log2FC, CSF_Markers_134$p_val_adj),]
write.csv(CSF_Markers_134, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_134_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_134 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_134_700cells_percondition_downsample_minpct0.1.csv"))

CSF_Markers_159 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00159_CSF", ident.2 = "SANTB00159_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_159 <- CSF_Markers_159[order(-CSF_Markers_159$avg_log2FC, CSF_Markers_159$p_val_adj),]
write.csv(CSF_Markers_159, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_159_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_159 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_159_700cells_percondition_downsample_minpct0.1.csv"))


CSF_Markers_448 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00448_CSF", ident.2 = "SANTB00448_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_448 <- CSF_Markers_448[order(-CSF_Markers_448$avg_log2FC, CSF_Markers_448$p_val_adj),]
write.csv(CSF_Markers_448, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_448_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_448 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_448_700cells_percondition_downsample_minpct0.1.csv"))


CSF_Markers_468 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00468_CSF", ident.2 = "SANTB00468_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_468 <- CSF_Markers_468[order(-CSF_Markers_468$avg_log2FC, CSF_Markers_468$p_val_adj),]
write.csv(CSF_Markers_468, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_468_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_468 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_468_700cells_percondition_downsample_minpct0.1.csv"))


CSF_Markers_469 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00469_CSF", ident.2 = "SANTB00469_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_469 <- CSF_Markers_469[order(-CSF_Markers_469$avg_log2FC, CSF_Markers_469$p_val_adj),]
write.csv(CSF_Markers_469, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_469_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_469 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_469_700cells_percondition_downsample_minpct0.1.csv"))


CSF_Markers_497 <- FindMarkers(GBM_700cells, ident.1 = "SANTB00497_CSF", ident.2 = "SANTB00497_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_497 <- CSF_Markers_497[order(-CSF_Markers_497$avg_log2FC, CSF_Markers_497$p_val_adj),]
write.csv(CSF_Markers_497, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_497_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_497 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_497_700cells_percondition_downsample_minpct0.1.csv"))

CSF_Markers_BAH1 <- FindMarkers(GBM_700cells, ident.1 = "BAH1_CSF", ident.2 = "BAH1_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_BAH1 <- CSF_Markers_BAH1[order(-CSF_Markers_BAH1$avg_log2FC, CSF_Markers_BAH1$p_val_adj),]
write.csv(CSF_Markers_BAH1, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_BAH1_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_BAH1 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_BAH1_700cells_percondition_downsample_minpct0.1.csv"))

CSF_Markers_HW1 <- FindMarkers(GBM_700cells, ident.1 = "HW1_CSF", ident.2 = "HW1_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_HW1 <- CSF_Markers_HW1[order(-CSF_Markers_HW1$avg_log2FC, CSF_Markers_HW1$p_val_adj),]
write.csv(CSF_Markers_HW1, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_HW1_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_HW1 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_HW1_700cells_percondition_downsample_minpct0.1.csv"))

CSF_Markers_MN1 <- FindMarkers(GBM_700cells, ident.1 = "MN1_CSF", ident.2 = "MN1_TME", min.pct = 0.1, logfc.threshold = 0, min.diff.pct = 0.05)
##Order CSF and TME markers by descending avg_logFC and increasing adjusted p-value
CSF_Markers_MN1 <- CSF_Markers_MN1[order(-CSF_Markers_MN1$avg_log2FC, CSF_Markers_MN1$p_val_adj),]
write.csv(CSF_Markers_MN1, file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_MN1_700cells_percondition_downsample_minpct0.1.csv"))
CSF_Markers_MN1 <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/CSF_Markers_HW1_700cells_percondition_downsample_minpct0.1.csv"))

##Create a matrix containing the top genes from the differential expression of all cells
Fold_change <- data.frame(matrix(ncol = 10, nrow=3585))
col_names <- c("111", "134", "159", "448", "468", "469", "497", "BAH1","MN1", "HW1")
colnames(Fold_change) <- col_names
rownames(Fold_change) <- rownames(CSF_Markers[c(1:3585),])

##We now subset the differential expression analysis based on the top genes
Genes <- as.character(rownames(Fold_change))
SB111 <- CSF_Markers_111[Genes,]
SB134 <- CSF_Markers_134[Genes,]
SB159 <- CSF_Markers_159[Genes,]
SB448 <- CSF_Markers_448[Genes,]
SB468 <- CSF_Markers_468[Genes,]
SB469 <- CSF_Markers_469[Genes,]
SB497 <- CSF_Markers_497[Genes,]
BAH1 <- CSF_Markers_BAH1[Genes,]
HW1 <- CSF_Markers_HW1[Genes,]
MN1 <- CSF_Markers_MN1[Genes,]

Fold_change$`111` <- SB111$avg_log2FC
Fold_change$`134` <- SB134$avg_log2FC
Fold_change$`159` <- SB159$avg_log2FC
Fold_change$`448` <- SB448$avg_log2FC
Fold_change$`468` <- SB468$avg_log2FC
Fold_change$`469` <- SB469$avg_log2FC
Fold_change$`497` <- SB497$avg_log2FC
Fold_change$`BAH1` <- BAH1$avg_log2FC
Fold_change$`HW1` <- HW1$avg_log2FC
Fold_change$`MN1` <- MN1$avg_log2FC

Average_fold_change <- data.frame(matrix(ncol = 1, nrow = 3585))
col_names <- c("Average FC")
colnames(Average_fold_change) <- col_names
rownames(Average_fold_change) <- rownames(Fold_change[1:3585,])
Average_fold_change$`Average FC` <- rowMeans(Fold_change[,1:10], na.rm = TRUE)
Average_fold_change$`Average FC` <- Average_fold_change[order(-Average_fold_change$`Average FC`),]

##Perform Clustering 
library(factoextra)
library(rafalib)
Dist <- dist(t(Fold_change)) #Calculate Distance 
Clust <- hclust(Dist)
plot(Clust)
rect.hclust(Clust, h=20)
lapply(rect.hclust(Clust, h=20), length)
##Save split cluster dendogram
##pdf(file = paste(resultsdirectory, "DendAllSamples_Split(7).pdf", sep = "/"), width = 24, height = 8, onefile = TRUE) ##Run to save as pdf
clusters_FC <- rect.hclust(Clust, h=20) ##also create clusters object containing clusters and cell barcodes

ClusterList <- list()
for(i in 1:length(clusters_FC)) {
  ClusterList[[i]] <- names(clusters_FC[[i]])
}
```

12. ***We now perform DE between Cycling, NonCycling OR MESlike OR Quiescent, NonQuiescent cells in CSF and TME. For Venn Diagram, SUPP FIGURE 5B***

```{Conduct DE for Proliferation and MES-like}
##Differential expression 
##Add new columns of Condition_Quadrant, Condition_Proliferation, Condition_Quiescence. Run this AFTER calculating meta-module, proliferation, quiescence scores as above. 

## DE for CellCycle ####
GBM_700cells$Condition_Proliferation <- paste(GBM_700cells$Cell_Cycle, GBM_700cells$Condition, sep = "_")

Idents(GBM_700cells) <- "Condition_Proliferation"
Cycling_Markers <-FindMarkers(GBM_700cells, ident.1 = "Cycling_CSF", ident.2 = "Cycling_TME", min.pct = 0.3, min.diff.pct = 0.05, logfc.threshold = 0)
NonCycling_Markers <- FindMarkers(GBM_700cells, ident.1 = "NonCycling_CSF", ident.2 = "NonCycling_TME", min.pct = 0.3, min.diff.pct = 0.05, logfc.threshold = 0)
write.csv(Cycling_Markers, file = paste0(resultsdirectory,"/Differential Expression/Downsampled_Cycling_Markers.csv"))
write.csv(NonCycling_Markers, file = paste0(resultsdirectory,"/Differential Expression/Downsampled_NonCycling_Markers.csv"))

## DE for Quiescence ####
GBM_700cells$Condition_Quiescence <- paste(GBM_700cells$Quiescence, GBM_700cells$Condition, sep = "_")
Idents(GBM_700cells) <- "Condition_Quiescence"
Quiescent_Markers <-FindMarkers(GBM_700cells, ident.1 = "Quiescent_CSF", ident.2 = "Quiescent_TME", min.pct = 0.3, min.diff.pct = 0.05, logfc.threshold = 0)
NonQuiescent_Markers <- FindMarkers(GBM_700cells, ident.1 = "NonQuiescent_CSF", ident.2 = "NonQuiescent_TME", min.pct = 0.3, min.diff.pct = 0.05, logfc.threshold = 0)

write.csv(Quiescent_Markers, file = paste0(resultsdirectory,"/Differential Expression/Quiescent_Markers.csv"))
write.csv(NonQuiescent_Markers, file = paste0(resultsdirectory,"/Differential Expression/NonQuiescent_Markers.csv"))

## DE for MESlike ####
GBM_700cells$Condition_Quadrant <- paste(GBM_700cells$Quadrant, GBM_700cells$Condition, sep = "_")
Idents(GBM_700cells) <- "Condition_Quadrant"
MES_Markers <-FindMarkers(GBM_700cells, ident.1 = "MESlike_CSF", ident.2 = "MESlike_TME", min.pct = 0.3, min.diff.pct = 0.05, logfc.threshold = 0)
write.csv(MES_Markers, file = paste0(resultsdirectory,"/Differential Expression/Downsampled_MES_Markers.csv"))
```

13.We perform GO analyses of top DE genes 
```{GO and GSEA - GBM_700cells}
## Load CSF markers
CSF_Markers <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/All_CSF_Markers_700cells_percondition_downsample-minpct0.1.csv"), row.names = "X")
CSF_Markers <- CSF_Markers[order(-CSF_Markers$avg_log2FC, CSF_Markers$p_val_adj),]

# add a column for UP and DOWN regulated genes.
CSF_Markers$diffexpressed <- "NO"
# if log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
CSF_Markers$diffexpressed[CSF_Markers$avg_log2FC > 0.5 & CSF_Markers$score > 100] <- "UP"
# if log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
CSF_Markers$diffexpressed[CSF_Markers$avg_log2FC < -0.5 & CSF_Markers$score > 100] <-  "DOWN"

# add a column of NAs
CSF_Markers$delabel <- NA
CSF_Markers$delabel[CSF_Markers$diffexpressed != "NO"] <- rownames(CSF_Markers)[CSF_Markers$diffexpressed != "NO"]

CSF_Markers$p_val_adj[which(CSF_Markers$p_val_adj == 0)] <- 1e-304
CSF_Markers$score <- (-log10(CSF_Markers$p_val_adj))*sign(CSF_Markers$avg_log2FC)
CSF_Markers <- CSF_Markers[order(-CSF_Markers$score),]
CSF_Markers$rank <- 1:nrow(CSF_Markers)

### Use this if you want to run fgsea analysis ####
library(fgsea)
library(data.table)
library(msigdbr)
library(org.Hs.eg.db)

Hallmark <- msigdbr(species = "Homo sapiens", category = "H")
Hallmark <- Hallmark %>% 
  dplyr::select(gs_name, gene_symbol, entrez_gene)
Hallmark <-  split(as.character(Hallmark$entrez_gene), Hallmark$gs_name)

Phenotype <- msigdbr(species = "Homo sapiens", category = "C5", subcategory = "HPO") ##BP for biological process, MF Molecular Function, CC Cellular Componenet, HPO Human Phenotype Ontology. 

Phenotype <- Phenotype %>% 
  dplyr::select(gs_name, gene_symbol,entrez_gene, ensembl_gene)
Phenotype <-  split(as.character(Phenotype$gene_symbol), Phenotype$gs_name)

geneList <- c(top20$avg_log2FC, bottom20$avg_log2FC)
names(geneList) <- c(rownames(top20),rownames(bottom20))

fgsea <- fgsea(Phenotype, geneList)
fgsea <- fgsea[fgsea$padj <= 0.05 & fgsea$size >= 10,]


##### Run Gene Ontology Analyses ####
library(data.table)
library(msigdbr)
library(clusterProfiler)
library(enrichplot)
library(org.Hs.eg.db)

#### For ClusterProfiler Analysis ####
## For GO and GO over-representation analysis we select the top DE genes based on Log2FC > 0.5 or top 100 markers
##gene_ids <- rownames(CSF_Markers)[CSF_Markers$avg_log2FC >= 0.5 | CSF_Markers$avg_log2FC <= -0.5]

top20 <- CSF_Markers %>% top_n(n = 20, wt = avg_log2FC)
bottom20 <- CSF_Markers %>% top_n(n =-20, wt = avg_log2FC)
gene_ids <- c(rownames(top20),rownames(bottom20))

all_genes <- as.matrix(GBM_700cells[["RNA"]]@counts)
all_genes <- row.names(all_genes)

enrichGO <- enrichGO(gene = gene_ids,
           universe = all_genes,
                OrgDb = "org.Hs.eg.db",
                ont           = "BP",
                keyType = "SYMBOL",
                pvalueCutoff  = 0.05,
                qvalueCutoff  = 0.01,
                readable      = TRUE)
save(enrichGO, file = paste(resultsdirectory, "/GSEA/GOenrichment_ORA_percluster_GBM_700cells_top20_updownregulated_BP_Ontology.RData", sep = "")) ## saved 310123
write.csv(enrichGO@result, file = paste(resultsdirectory, "/GSEA/sheets/GOenrichment_ORA_percluster_GBM_700cells_top20_updownregulated_BP_Ontology.csv", sep = "")) ## saved 310123

library(simplifyEnrichment)
enrichGO_results <- enrichGO@result[enrichGO@result$p.adjust <= 0.05,]
enrichGO_results <- enrichGO_results[!duplicated(enrichGO_results$geneID),] ## remove any duplicated geneIDs
go_id <- enrichGO_results$ID
go_mat <- GO_similarity(go_id, ont = "BP", measure = "Wang")

## See how many clusters can be generated 
clt <- cmp_make_clusters(go_mat)

## generate clusters using either k-means clustering or louvain clustering. 
go_cluster <- simplifyGO(go_mat, method = "kmeans") ##8 clusters generated - but this may change each time you run. 
go_cluster_louvain <- simplifyGO(go_mat, method = "louvain") ## 8 clusters

## Add cluster numbers to enrichGO results. 
enrichGO_results$Cluster_kmeans <- go_cluster$cluster[match(enrichGO_results$ID, go_cluster$id)]
enrichGO_results$Cluster_kmeans <- go_cluster$cluster[match(enrichGO_results$ID, go_cluster$id)]

enrichGO_results$Cluster_louvain <- go_cluster_louvain$cluster[match(enrichGO_results$ID, go_cluster_louvain$id)]
enrichGO_results$Cluster_louvain <- go_cluster_louvain$cluster[match(enrichGO_results$ID, go_cluster_louvain$id)]

## Create similarity matrix
## Louvain clustering was used for CSF paper - kmeans clustering provided variable clustering each time
ha_louvain = HeatmapAnnotation(clusters = go_cluster_louvain$cluster, 
                       col = list(clusters = c("1" = "coral",
  "2" = "#5BE885",
  "3" = "purple",
  "4" = "goldenrod1",
  "5" = "red",
  "6" = "darksalmon",
  "7" = "darkorange",
  "8" = "royalblue1"
  )))

ha_kmeans = HeatmapAnnotation(clusters = go_cluster$cluster, 
                       col = list(clusters = c("1" = "coral",
  "2" = "#5BE885",
  "3" = "purple",
  "4" = "goldenrod1",
  "5" = "red",
  "6" = "darksalmon",
  "7" = "darkorange",
  "8" = "royalblue1"
  )))

## generate word cloud annotations
## NOTE: word cloud annotations do not show up properly in the plots pane. Save as pdf to view heatmap properly. 
word_cloud_louvain <- rowAnnotation(GO_term = anno_word_cloud_from_GO(go_cluster_louvain$cluster, go_cluster_louvain$id))
word_cloud_kmeans <- rowAnnotation(GO_term = anno_word_cloud_from_GO(go_cluster$cluster, go_cluster$id))

pdf(file = paste(resultsdirectory,"plots/GO and GSEA/GO_similarity_matrix_louvain_clustering.pdf", sep = "/"), width = 12, height = 12)
hm <- Heatmap(go_mat,
        col = c("white","red","firebrick"),
        row_split = go_cluster_louvain$cluster,
        column_split = go_cluster_louvain$cluster,
        show_row_names = F,
        show_column_names = F,
        show_row_dend = T,
        show_column_dend = T,
        cluster_row_slices = F,
        cluster_column_slices = F,
        cluster_rows = F,
        cluster_columns = F,
        top_annotation = ha_louvain,
        row_title = "cluster",
        column_title = "cluster", 
        width = unit(15, "cm"),
        height = unit(15, "cm"),
        right_annotation = word_cloud_louvain,
       row_names_gp =  gpar(fontsize = 12),
       ##column_dend_height = unit(1, "cm"),
       ##row_dend_width = unit(1, "cm"),
       heatmap_legend_param = list(title = "Similarity"))
draw(hm)
dev.off()

#####
## Assign new definitions to clusters.
enrichGO_results$new_description <- ifelse(enrichGO_results$Cluster_louvain == "1", "cell migration", ifelse(enrichGO_results$Cluster_louvain == "2", "response to extracellular signals", ifelse(enrichGO_results$Cluster_louvain == "3", "metabolic processes", 
ifelse(enrichGO_results$Cluster_louvain == "4", "development", 
ifelse(enrichGO_results$Cluster_louvain == "5", "regulation of apoptotic processes", 
ifelse(enrichGO_results$Cluster_louvain == "6", "endoplasmic reticulum stress response",
ifelse(enrichGO_results$Cluster_louvain == "7", "negative growth regulation","cell division")))))))

## We now create a chord plot with new cluster definitions.  
library(GOplot)
enrichGO_results <- enrichGO_results[order(enrichGO_results$p.adjust),]
enrichGO_list <- list()
enrichGO_list$results <- data.frame("Category" = "BP", "ID" = enrichGO_results$Cluster_louvain, "Term" = enrichGO_results$new_description, "Genes" = enrichGO_results$geneID, "adj_pval" = enrichGO_results$p.adjust)
enrichGO_list$results$Genes <- gsub("/",",",enrichGO_list$results$Genes)

## Make genes list
geneList <- rbind(top20, bottom20)
enrichGO_list$geneList <- data.frame("ID" = rownames(geneList), "logFC" = geneList$avg_log2FC)
circ <- circle_dat(enrichGO_list$results, enrichGO_list$geneList)
enrichGO_list$process <- unique(circ$term)
GOCircle(circ, nsub = 8, rad1 = 2, rad2 = 3)
chord <- chord_dat(circ, enrichGO_list$geneList, enrichGO_list$process)

write.csv(circ, file = paste(resultsdirectory, "/GSEA/sheets/ChordPlot_GOenrichment_ORA_percluster_GBM_700cells_top20_updownregulated_BP_Ontology.csv", sep = ""))

write.csv(enrichGO_results, file = paste(resultsdirectory, "/GSEA/sheets/GOenrichment_ORA_top20_updownregulated_BP_Ontology_wnewcluster_description.csv", sep = "")) ## saved 310123

# Display only genes which are assigned to at least three processes
pdf(file = paste0(resultsdirectory,"/plots/GO and GSEA/GOChord_top20rankedgenes_louvainclustering_legend.pdf"), width = 6, height = 6)
GOChord(chord, nlfc = 1, limit = c(0,0), 
        space = 0.02, 
        gene.space = 0.25, 
        gene.order = "logFC", 
        border.size = 0, 
        ribbon.col = c("darkorange","goldenrod1","royalblue1","#5BE885","red","darksalmon","purple","coral"),
        gene.size = 3, 
        process.label = 5,
        lfc.min = -1.79,
        lfc.max = 1.57,
        lfc.col = c("red","white","blue")) ##+ NoLegend()
dev.off()

save(enrichGO, enrichGO_results, go_mat, go_cluster, go_cluster_louvain, word_cloud_kmeans, word_cloud_louvain, file = paste(resultsdirectory, "GSEA/GOenrichment_ORA_GO_Clustering.RData", sep = "")) 

## convert symbols to entrez ids
hs <- org.Hs.eg.db
entrez_genes <- select(hs, 
       keys = gene_ids,
       columns = c("ENTREZID", "SYMBOL"),
       keytype = "SYMBOL")
all_genes_entrez <- select(hs, 
       keys = all_genes,
       columns = c("ENTREZID", "SYMBOL"),
       keytype = "SYMBOL")
all_genes_entrez <- all_genes_entrez[!is.na(all_genes_entrez$ENTREZID),]

library(data.table)
library(dplyr)
library(formattable)
library(tidyr)

GO_terms_cluster <- read.csv(file = paste0(resultsdirectory,"/GBM_All_sheets/GO_terms_percluster.csv"))

GO_terms_cluster <- enrichGO_results %>% summarise(new_description, ID)
GO_terms_cluster <- reshape2::dcast(GO_terms_cluster, new_description ~ ID)
names(GO_terms_cluster)[2:83] <- 1:82
rownames(GO_terms_cluster) <- GO_terms_cluster$new_description
GO_terms_cluster$new_description <- NULL
GO_terms_cluster[is.na(GO_terms_cluster)] <- ''

paste0(GO_terms_cluster[,1:82], sep = ",")
  
formattable(GO_terms_cluster, align = c("l",rep("r", NCOL(GO_terms_cluster) - 1)))
```

14.We visualise the expression of potential NUPR1 pathway markers
```{We visualise the expression of potential NUPR1 pathway markers}
## Create cluster annotation
library(ComplexHeatmap)
library(grid)
library(circlize)
library(pals)
library(magick)
library(dendsort)
library(colorspace)

Idents(GBM_700cells) <- "Condition_PatientID"
seurat_cluster.averages <- AverageExpression(GBM_700cells, return.seurat = FALSE)
seurat_cluster.averages

## Subset seurat object for NUPR1 regulated
##subset.matrix <- seurat_cluster.averages[["RNA"]][c("NUPR1","RELB","CDKN1A","SNAP25","BECN1", "RAB31", "GREB1", "CYP1B1", "NEDD9", "GRN", "DNMT1"),]

subset.matrix <- seurat_cluster.averages[["RNA"]][c("NUPR1","RELB","CDKN1A","GRN", "DNMT1", "MGST1", "TP53","NES"),] ## this is the list that will be used by Brett
write.csv(subset.matrix, file = paste0(resultsdirectory, "/GBM_All_sheets/NUPR1_transcriptional_targets_average_expression_GBM_700cells.csv"))

## Calculate fold change
library(stringr)
subset.matrix <- as.data.frame(t(subset.matrix))
subset.matrix[c("PatientID", "Condition")] <- str_split_fixed(rownames(subset.matrix), '_', 2)
subset.matrix <- split(subset.matrix, subset.matrix$PatientID)

## Fold change of average NUPR1 gene expression
subset.matrix_FC <- lapply(subset.matrix, function(x){
  x[,9:10] <- NULL
  x[grep("CSF",rownames(x)),]/x[grep("TME",rownames(x)),]
})
subset.matrix_FC <- do.call("rbind", subset.matrix_FC)
subset.matrix_FC <- as.matrix(t(round(subset.matrix_FC,2)))
colnames(subset.matrix_FC) <- c("BAH1","HW1","MN1","111","134","159","448","468","469","497")

All_Treatment <- read.csv(file = paste0(datadirectory, "/reference_sheets/TME_CSF_Treatment.csv"), row.names = "X")
All_Treatment <- All_Treatment[c("111","134","159","448","468","469","497","BAH1","HW1","MN1"),6:10]
All_Treatment[is.na(All_Treatment)] <- 0

All_Treatment <- t(All_Treatment[match(colnames(subset.matrix_FC), rownames(All_Treatment)),])

column_ha <- HeatmapAnnotation(Survival = anno_barplot(All_Treatment[3,], beside = TRUE, attach = TRUE)) ## TFP survival

## Create Heatmap annotations
color_h <- colorRamp2(c(0,1,2.5,7.5,10,15), c("blue","white","orange","coral","red","firebrick"))

hm <- ComplexHeatmap::Heatmap(subset.matrix_FC,
                              border = TRUE,
                              show_row_names = T,
                              show_column_names = T,
                              cluster_rows = T,
                              cluster_columns = T,
                              width = unit(12, "cm"),
                              height = unit(12, "cm"),
                              column_dend_reorder = T,
                              bottom_annotation = column_ha,
                              col = color_h,
                              na_col = "grey",
                              row_dend_reorder = T,
                              show_row_dend = T, 
                              show_column_dend = T,
                              row_names_gp =  gpar(fontsize = 12),
                              column_dend_height = unit(1, "cm"),
                              row_dend_width = unit(1, "cm"),
                              cell_fun = function(j, i, x, y, width, height, fill) {
                                grid.text(sprintf("%.1f", subset.matrix_FC[i,j]), 
                                          x, y, gp = gpar(fontsize = 15))},
                              heatmap_legend_param = list(
               title = "Fold change (CSF/GM)",at = c(0,2.5,7.5,10,12.5,15)))
## c(-2, 0, 2, 4)
pdf(file = paste(resultsdirectory,"plots/Differential expression/Heatmap/Fold_change_NUPR1_regulated_genes.pdf", sep = "/"), width = 12, height = 12)
draw(hm)
dev.off()

enrichGO_results <- enrichGO_results[order(enrichGO_results$Cluster_louvain),]
top20 <- top20[order(-top20$avg_log2FC),]
bottom20 <- bottom20[order(-bottom20$avg_log2FC),]
gene_ids <- c(rownames(top20), rownames(bottom20))
gene_ids <- gene_ids[(gene_ids %in% unique(circ$genes))]

color_h <- colorRamp2(c(0,1), c("grey95","grey35"))
hm <- ComplexHeatmap::Heatmap(chord[,1:8],
                              border = TRUE,
                              show_row_names = T,
                              show_column_names = T,
                              column_order = unique(enrichGO_results$new_description),
                              row_order = gene_ids,
                              cluster_rows = F,
                              cluster_columns = F,
                              width = unit(12, "cm"),
                              height = unit(12, "cm"),
                              column_dend_reorder = F,
                              col = color_h,
                              na_col = "grey",
                              rect_gp = gpar(col = "white", lwd = 1),
                              row_dend_reorder = F,
                              show_row_dend = T, 
                              show_column_dend = T,
                              row_names_gp =  gpar(fontsize = 12),
                              column_dend_height = unit(1, "cm"),
                              row_dend_width = unit(1, "cm"))
pdf(file = paste(resultsdirectory,"plots/Differential expression/Heatmap/GOterms_top20genes_heatmap.pdf", sep = "/"), width = 12, height = 12)
draw(hm)
dev.off()

proportions_seurat_clusters <- GBM_700cells@meta.data %>%
  group_by(Condition_PatientID, Quadrant) %>%
  summarise(n = n()) %>%
  mutate(freq = (n/sum(n))*100)

proportions_seurat_clusters$freq <- round(proportions_seurat_clusters$freq,2)
proportions_seurat_clusters$Quadrant <- factor(proportions_seurat_clusters$Quadrant, levels = c("AClike","MESlike","NPClike","OPClike"))

pie <- ggplot(proportions_seurat_clusters, aes(x ="", y = proportions_seurat_clusters$freq, fill = proportions_seurat_clusters$Quadrant)) +
  geom_col() +
  ##geom_text(aes(label = proportions_seurat_clusters$freq), position = position_stack(vjust = 1)) +
  coord_polar(theta = "y") +
  theme_void() +
  facet_grid(~Condition_PatientID) +
  scale_fill_manual(values = c("AClike" = "goldenrod1", "MESlike" = "red","NPClike" = "saddlebrown","OPClike" = "royalblue")) + theme(legend.position = "none") 
pie
ggsave(pie, filename = paste(resultsdirectory, "/plots/Pie charts/GBM_700cells__Cellstate_proportions_per_Condition_PatientID_NoLegend.pdf", sep = "/"), height = 6, width = 20, dpi = 300, useDingbats = FALSE)
```

i. ***We will now visualise analysed data. i. FIGURE 3 and SUPP FIGURE 3.***
```{RNA seq Plots for Figure 3 and Supp Figure 3}
## FIGURE 3D AND E: Proliferation scatter plots with ggplot2. ####
## geom_pointdenisty from the ggpointdensity package (recently developed by Lukas Kremer and Simon Anders (2019)) allows you visualize density and individual data points at the same time
## individual points are colored by the number of neighboring points. This allows you to see the overall distribution, as well as individual points
library(ggplot2)
library(ggpointdensity)
Bardy_10x$Condition <- factor(Bardy_10x$Condition, levels = c("TME", "CSF")) ##Set ;evels for plotting order. 
int_breaks <- function(x, n = 5) pretty(x, n)[pretty(x, n) %% 1 == 0] ## function to generate only whole-integer breaks for x and y axis ticks
scatterPlot <- ggplot(Bardy_10x@meta.data, aes(x = G1S.Score , y = G2M.Score)) + ## transform to change the order of the plots in facet_wrap()
  geom_vline(xintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_hline(yintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_point(size = 2) +
  geom_pointdensity(adjust = 0.5) +
  scale_colour_gradientn(colours = colorRampPalette(rev(brewer.pal(11,'Spectral')))(25),
                         breaks = seq(0,28000,4000),
                         limits = c(0,28000)) +
  ## scale_color_viridis_c() +
  ## facet_wrap( ~ Condition_PatientID) +
  theme_bw() +
  theme(legend.position = "right", axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20), axis.title.x = element_text(size = 20), axis.title.y = element_text(size = 20), panel.border = element_rect(fill=NA, colour = "black", size=1.5)) +
  xlab(expression(atop("G1S Score"))) + ylab(expression(atop("G2M Score"))) +
  scale_x_continuous(breaks = int_breaks) +
  scale_y_continuous(breaks = int_breaks) +
  coord_cartesian(xlim = c(-0.5,1.25), ylim = c(-0.5, 1.75))
scatterPlot
ggsave(scatterPlot, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_proliferation_alltumours_scale0-28000_legend.pdf"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)

##FIGURE 3F and I: Proliferation and Quiescence Score Ridge Plots.####
RP <- RidgePlot(Bardy_10x, group.by = "Proliferation.Score", log = FALSE)  + ##you can replace the group.by variable to any column on the metadata. Change to "Quiescent.Score" for Figure 3I. 
  theme(legend.position = "none", legend.text = element_text(size = 16), legend.justification = "center")
RP
ggsave(RP, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_RP_ProliferationScore_NoLegend.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)

###SUPP FIGURE 3A: UMAP plot to visualise Cyclcing and NonCycling Cells ####
umap <- DimPlot(Bardy_10x, reduction = "umap", pt.size = 0.2, label = FALSE, repel = FALSE, group.by = "CellCycle", split.by = "Condition", cols = c("blue","red"))  + ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "bottom", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=1.5))  + 
  coord_cartesian(xlim = c(-15,15), ylim = c(-15, 15)) 
umap
ggsave(umap, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_Proliferation_splitbyCondition_Legend.pdf", sep = "/"), height = 6, width = 12, dpi = 300, useDingbats = FALSE)

##SUPP FIGURE 3B: Feature Plot by to visualise  expression of MKI67
FP <- FeaturePlot(Bardy_10x, features = "MKI67", pt.size = 0.2, label = FALSE, repel = FALSE, split.by = "Condition", cols = c("lightgrey","red"), order = TRUE, keep.scale = "all") & ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "bottom", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=1.5))  & 
  coord_cartesian(xlim = c(-15,15), ylim = c(-15, 15)) 
FP 
ggsave(FP, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_MKI67_Condition_Legend.pdf", sep = "/"), height = 6, width = 14, dpi = 300, useDingbats = FALSE)
```

ii. ***FIGURE 4 and SUPP FIGURE 4.***

```{RNA seq Plots for Figure 4 and Supp Figure 4}
## FIGURE 4A-C: Recreate Neftel meta-module plots with ggplot2. ####
library(ggplot2)
library(ggpointdensity)
Bardy_10x$Condition <- factor(Bardy_10x$Condition, levels = c("TME", "CSF")) ##Set ;evels for plotting order. 
int_breaks <- function(x, n = 5) pretty(x, n)[pretty(x, n) %% 1 == 0] ## function to generate only whole-integer breaks for x and y axis ticks
scatterPlot <- ggplot(Bardy_10x@meta.data, aes(x = rel.metamodule.x.score, y = rel.metamodule.y.score)) + ## transform to change the order of the plots in facet_wrap()
  geom_vline(xintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_hline(yintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_point(size = 2) +
  geom_pointdensity(adjust = 0.5) +
  scale_colour_gradientn(colours = colorRampPalette(rev(brewer.pal(11,'Spectral')))(25),
                         breaks = seq(0,2000,250), ##12550 for all legends 2500 limit
                         limits = c(0,2000)) + ##12550 for all legends
  ## scale_color_viridis_c() +
  facet_wrap( ~ Condition_PatientID) + ##Condition or Condition_PatientID to generate split scatter plots by Condition or PatientID
  theme_bw() +
  theme(legend.position = "none", axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20), axis.title.x = element_text(size = 20), axis.title.y = element_text(size = 20), panel.border = element_rect(fill=NA, colour = "black", size=1.5)) +
  xlab(expression(atop("Relative meta-module score", paste("[log2(|SC1-SC2|+1)]")))) + ylab(expression(atop("Relative meta-module score", paste("[log2(|SC1-SC2|+1)]")))) +
  scale_x_continuous(breaks = int_breaks) +
  scale_y_continuous(breaks = int_breaks) +
  coord_cartesian(xlim = c(-1.25, 1.25), ylim = c(-1.25, 1.25))
scatterPlot
ggsave(scatterPlot, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_metamodules_bypatient_alltumours_scale0-2000_nolegend.pdf", sep = "/"), height = 12, width = 12, dpi = 300, useDingbats = FALSE)

## FIGURE 4F, J and I: Ridge plot of MESlike and MESlike 1, 2 Scores.####
RP <- RidgePlot(Bardy_10x, group.by = "MESlike.Score", log = FALSE)  + ##you can replace the group.by variable to any column on the metadata. Change to "Quiescent.Score" for Figure 3I. 
  theme(legend.position = "none", legend.text = element_text(size = 16), legend.justification = "center")
RP
ggsave(RP, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_RP_MESlikeScore_NoLegend.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)

## FIGURE 4E: PIE CHARTS OF CELL PROPORTIONS
GBM_metadata <- Bardy_10x@meta.data
GBM_metadata <- GBM_metadata[,-c(1:3,7:26,28:31,34:36,39:40,42:48,50:52,55)]

proportions_neftel <- GBM_metadata %>%
  group_by(Condition, PatientID, Quadrant) %>%
  summarise(n = n()) %>%
  mutate(freq = (n/sum(n))*100)

proportions_neftel$freq <- round(proportions_neftel$freq, 2)
proportions_neftel$PatientID <- factor(proportions_neftel$PatientID, levels = c("BAH1","HW1","MN1","SANTB00111","SANTB00134","SANTB00159","SANTB00448","SANTB00468","SANTB00469","SANTB00497"))

ggplot(proportions_neftel, aes(x = "", y = proportions_neftel$freq, fill = proportions_neftel$Quadrant)) +
  geom_col() +
  ##geom_text(aes(label = proportions_neftel$freq), position = position_stack(vjust = 1)) +
  coord_polar(theta = "y") +
  theme_void() +
  facet_grid(Condition ~ PatientID) +
  scale_fill_manual(values = c("#FECC66","#FB0207","#804003","#0F80FF")) + theme(legend.position = "none")

## FIGURE 4H and I: Proliferation and MES-like scatter plots with ggplot2. ####
int_breaks <- function(x, n = 5) pretty(x, n)[pretty(x, n) %% 1 == 0] ## function to generate only whole-integer breaks for x and y axis ticks
scatterPlot <- ggplot(Bardy_10x@meta.data, aes(x = MESlike.Score , y = Proliferation.Score)) + ## transform to change the order of the plots in facet_wrap()
  geom_vline(xintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_hline(yintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_point(size = 2) +
  geom_pointdensity(adjust = 0.5) +
  scale_colour_gradientn(colours = colorRampPalette(rev(brewer.pal(11,'Spectral')))(25),
                         breaks = seq(0,13000,2000),
                         limits = c(0,13000)) +
  ## scale_color_viridis_c() +
  ## facet_wrap( ~ Condition_PatientID) +
  theme_bw() +
  theme(legend.position = "none", axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20), axis.title.x = element_text(size = 20), axis.title.y = element_text(size = 20), panel.border = element_rect(fill=NA, colour = "black", size=1.5)) +
  xlab(expression(atop("Relative MESlike Score"))) + ylab(expression(atop("Proliferation Score"))) +
  scale_x_continuous(breaks = int_breaks) +
  scale_y_continuous(breaks = int_breaks) +
  coord_cartesian(xlim = c(-0.5,1), ylim = c(-0.5, 1))
scatterPlot
ggsave(scatterPlot, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_proliferation_MESlike_alltumours_scale0-13000_nolegend.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)

## SUPP FIGURE 4A and B. Recreate Neftel meta-module plots with ggplot2 coloured by proliferation or quiescence scores. ####
library(ggplot2)
library(ggpointdensity)
Bardy_10x$Condition <- factor(Bardy_10x$Condition, levels = c("TME", "CSF"))
int_breaks <- function(x, n = 5) pretty(x, n)[pretty(x, n) %% 1 == 0] ## function to generate only whole-integer breaks for x and y axis ticks
scatterPlot <- ggplot(Bardy_10x@meta.data, aes(x = rel.metamodule.x.score, y = rel.metamodule.y.score)) + ## transform to change the order of the plots in facet_wrap()
  geom_vline(xintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_hline(yintercept=0, linetype="dotted", color = "black", size = 0.5) +
  geom_point(aes(color = Bardy_10x$Proliferation.Score), size = 1, alpha = 0.5) +
  scale_colour_gradientn(colours = colorRampPalette(rev(brewer.pal(11,'RdBu')))(25),
                        breaks = seq(-0.4,0.8,0.2), ##Change scale when changing between Quiescence or Proliferation scores.
                         limits = c(-0.4,0.8)) +
  ## scale_color_viridis_c() +
  facet_wrap( ~ Condition) + ##Split graph by condition.
  theme_bw() +
  theme(legend.position = "right", axis.text.x = element_text(size = 20), axis.text.y = element_text(size = 20), axis.title.x = element_text(size = 20), axis.title.y = element_text(size = 20), panel.border = element_rect(fill=NA, colour = "black", size=1.5)) +
  xlab(expression(atop("Relative meta-module score", paste("[log2(|SC1-SC2|+1)]")))) + ylab(expression(atop("Relative meta-module score", paste("[log2(|SC1-SC2|+1)]")))) +
  scale_x_continuous(breaks = int_breaks) +
  scale_y_continuous(breaks = int_breaks) +
  coord_cartesian(xlim = c(-1.25, 1.25), ylim = c(-1.25, 1.25))
scatterPlot
ggsave(scatterPlot, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_metamodule_proliferation_all_nolegend.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)
## SUPP FIGURE 4D: Correlation Plot ####
GBM_Corr <- Bardy_10x@meta.data[,c(13:16,34:35,40)] ##With proliferation scores and Stem-cell scores
GBM_Corr <- as.data.frame(GBM_Corr)
Cor <- round(cor(GBM_Corr, method = "pearson"), 1)

head(Cor)
##install.packages("ggcorrplot")
library(ggcorrplot)
corplot <- ggcorrplot(Cor, lab = TRUE)
corplot
##ggsave(corplot, filename = paste0(resultsdirectory,"/plots/Heatmap/GBM_CorrelationPlot_All.pdf", sep = "/"), height = 8, width = 8, dpi = 300, useDingbats = FALSE)
ggsave(corplot, filename = paste0(resultsdirectory,"/plots/Heatmap/GBM_CorrelationPlot_NeftelTCGAStemCell.pdf", sep = "/"), height = 8, width = 8, dpi = 300, useDingbats = FALSE)

## SUPP FIGURE 4E and F: Stem cell gene expression ####
##We load csv containing stem cell signature and extract the Lathia Stem Cell Genes. 
stem_cell <- read.csv(file = paste(datadirectory,"/reference_sheets/Stemcell.Markers.csv"), header = TRUE)
Lathia_GSC <- as.character(stem_cell[c(1:7,9:21),1]) ##SSEA1 is not found in the dataset so we exclude it.

##Create a data.frame containing the top genes from the differential expression of all cells
Number_GSC <- data.frame(matrix(ncol = 20, nrow= 20))
col_names <- c("SANTB00111_GM", "SANTB00111_CSF", "SANTB00134_GM", "SANTB00134_CSF", "SANTB00159_GM", "SANTB00159_CSF","SANTB00448_GM", "SANTB00448_CSF","SANTB00468_GM", "SANTB00468_CSF","SANTB00469_GM", "SANTB00469_CSF", "SANTB00497_GM", "SANTB00497_CSF","BAH1_GM", "BAH1_CSF","HW1_GM", "HW1_CSF","MN1_GM", "MN1_CSF")
colnames(Number_GSC) <- col_names
rownames(Number_GSC) <- Lathia_GSC

##We subset the seurat object by Condition_PatientID
##REMEMBER: CHANGE THE PATIENT ID EACH TIME. 
Idents(GBM_700cells) <- "Condition_PatientID"
GBM_CSF <-  subset(x = GBM_700cells, subset = Condition_PatientID == "MN1_CSF")
GBM_TME <-  subset(x = GBM_700cells, subset = Condition_PatientID == "MN1_TME")

##We extract the RNA counts from each matrix and subset the matrix by the Lathia GSC genes. 
Matrix_CSF <- GBM_CSF@assays$RNA@counts
Matrix_CSF <- as.data.frame(Matrix_CSF)
Matrix_CSF <- Matrix_CSF[Lathia_GSC,]
Matrix_CSF <- na.omit(Matrix_CSF)

Matrix_TME <- GBM_TME@assays$RNA@counts
Matrix_TME <- as.data.frame(Matrix_TME)
Matrix_TME <- Matrix_TME[Lathia_GSC,]
Matrix_TME <- na.omit(Matrix_TME)

##We then run the for loop to count the number of cells that express the gene. Count > 0 
##We then add this to each column in the Number_GSC dataframe. 
##REMEMBER: CHANGE THE PATIENT ID EACH TIME. 

for(i in seq_along(1:nrow(Matrix_CSF))){
  Number_GSC$MN1_CSF <- rowSums(Matrix_CSF!=0)
}

for(i in seq_along(1:nrow(Matrix_TME))){
   Number_GSC$MN1_GM <- rowSums(Matrix_TME!=0)
}

##Divide the counts by the total number of cells and multiply by 100 to get proportion of cells expressing the gene.
Proportion_GSC <- (Number_GSC/700)*100

##Save CSV and plot data using PRISM
write.csv(as.data.frame(Proportion_GSC), file = paste0(workingdirectory, "Proportion_Lathia_GSC.csv"), quote = FALSE)
write.csv(as.data.frame(Number_GSC), file = paste0(workingdirectory, "Number_Lathia_GSC.csv"), quote = FALSE)
```

iii. ***FIGURE 5 and SUPP FIGURE 5.***

```{RNA seq Plots for Figure 5 and Supp Figure 5}
### FIGURE 5A: Volcano Plot for all cell lines ####
##CSF_Markers <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/All_CSF_Markers_700cells_percondition_downsample-minpct0.1.csv"))
CSF_Markers$p_val_new <- CSF_Markers$p_val_adj
CSF_Markers$p_val_new[which(CSF_Markers$p_val_adj == 0)] <- 1e-304
CSF_Markers$log10p_adj <- -log10(CSF_Markers$p_val_new)

# add a column for UP and DOWN regulated genes.
CSF_Markers$diffexpressed <- "NO"
# if log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
CSF_Markers$diffexpressed[CSF_Markers$avg_log2FC > 0.25 & CSF_Markers$log10p_adj > 100] <- "UP"
# if log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
CSF_Markers$diffexpressed[CSF_Markers$avg_log2FC < -0.25 & CSF_Markers$log10p_adj > 100] <-  "DOWN"

# add a column of NAs
CSF_Markers$delabel <- NA
CSF_Markers$delabel[CSF_Markers$diffexpressed != "NO"] <- rownames(CSF_Markers)[CSF_Markers$diffexpressed != "NO"]

library(ggrepel)
VP <- ggplot(CSF_Markers, aes(avg_log2FC, -log10(p_val_new), label=delabel, color=diffexpressed)) + geom_point(alpha = 0.5, size = 3) +
  coord_cartesian(xlim= c(-2,3)) + 
  scale_size() +
  theme_minimal() + 
  geom_text_repel(data=CSF_Markers, size = 3, max.overlaps = 30, direction = "both") +
  labs(y=expression('-Log'[10]*' P'[adj]), x=expression('Log'[2]*' fold change')) +
  scale_color_manual(values = c("blue","grey27","red")) + 
  theme(legend.position = "none", legend.text = element_text(size = 18), legend.justification = "center",axis.text.x = element_text(size = 18), axis.text.y = element_text(size = 18),axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 18), panel.border = element_rect(fill=NA, colour = "black", size=0.5)) + 
  geom_vline(xintercept = c(-0.5,0,0.5), linetype = "dashed", col = "black", size = 0.5) +
  geom_hline(yintercept = c(0.01,100), linetype = "dashed", col = "black", size = 0.5) +
  scale_x_continuous(breaks = seq(-2, 3, by = 1))
VP
ggsave(VP, filename = paste0(resultsdirectory, "plots/Differential expression/VP_top_genes_twocolour_downsampledcells.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)

## FIGURE 5B: Heatmap of top 20 genes ####
CSF_Markers <- read.csv(file = paste0(resultsdirectory,"/Differential Expression/All_CSF_Markers_700cells_percondition_downsample-minpct0.1.csv"))
library(RColorBrewer)
library(ComplexHeatmap)
library(circlize)
library(pals)
library(magick)
library(dendsort)
library(colorspace)

##Genes_order <- factor(rownames(Fold_change), levels = c("NUPR1","MTHFD2","PSAT1","SLC3A2","DDIT3","GJA1","GADD45B","TAGLN","PHGDH","TRIB3","RND3","GDF15","STC2","CCN2","CRYAB","SERPINE1","ATF4","SYNM","KRT81","CHI3L1"))
##Fold_change <- Fold_change[order(Genes_order),]
Heatmap <- Fold_change[c(1:20, 3566:3585),]
Heatmap <- as.matrix(Heatmap)

Genes_order <-factor(rownames(Fold_change), levels = rownames(Fold_change)[order(Average_fold_change[1:3585 ,], decreasing = T)])

color_h <- colorRamp2(c(-5,-2.5,-1,0,2.5,5), c("blue","deepskyblue","deepskyblue","white","red","firebrick"))

pdf(file = paste0(resultsdirectory, "plots/Heatmap/Heatmap_2_Downsampled.pdf"), width = 12, height = 12, onefile = T) ##Run to save as pdf
h <- Heatmap(Heatmap, show_row_names = TRUE,
             show_column_names = FALSE, 
             cluster_columns = function(m) as.dendrogram(Clust), 
             column_dend_reorder = T,
             row_dend_reorder = Genes_order,
             cluster_rows = F,
             show_row_dend = TRUE, 
             show_column_dend = TRUE,
             column_dend_height = unit(1, "cm"),
             row_dend_width = unit(2, "cm"),
             col = color_h, ##update colors in previous step
             use_raster = FALSE, 
             raster_device = "png",
             na_col = "grey",
             row_names_gp =  gpar(fontsize = 18),
             rect_gp = gpar(col = "white", lwd = 1),
             cell_fun = function(j, i, x, y, width, height, fill) {
        grid.text(sprintf("%.1f", Heatmap[i, j]), x, y, gp = gpar(fontsize = 18))},
             heatmap_legend_param = list(
               title = "Average Log2 FC", at = c(-5,-2.5,0,2.5,5)))
h

dev.off()

##Create a single heatmap for DE of ALL CELL LINES. 
Single_heatmap <- data.frame(matrix(ncol = 1, nrow= 40))
col_names <- c("Average FC")
colnames(Single_heatmap) <- col_names
rownames(Single_heatmap) <- rownames(CSF_Markers[c(1:20,3566:3585),])
Single_heatmap$`Average FC` <- CSF_Markers[c(1:20,3566:3585),2]
Single_heatmap$`Average FC` <- Single_heatmap[order(-Single_heatmap$`Average FC`),]
Single_heatmap <- as.matrix(Single_heatmap)

pdf(file = paste0(resultsdirectory, "/plots/Heatmap/SingleHeatmap_Downsampled.pdf"), width = 4, height = 12, onefile = T) ##Run to save as pdf

color_h <- colorRamp2(c(-2.5,-1,-0.5,0,2.5,5), c("blue","deepskyblue","deepskyblue","white","red","firebrick"))

h <- Heatmap(Single_heatmap[1:40,], 
             show_row_names = TRUE,
             show_column_names = FALSE, 
             ##column_dend_reorder = T,
             ##row_dend_reorder = Genes_order,
             row_names_gp =  gpar(fontsize = 18),
             cluster_rows = F,
             show_row_dend = TRUE, 
             show_column_dend = TRUE,
             column_dend_height = unit(1, "cm"),
             row_dend_width = unit(2, "cm"),
             col = color_h, ##update colors in previous step
             use_raster = FALSE, 
             raster_device = "png",
             ##top_annotation = top_a,
             rect_gp = gpar(col = "white", lwd = 1),
             cell_fun = function(j, i, x, y, width, height, fill) {
        grid.text(sprintf("%.1f", Single_heatmap[i, j]), x, y, gp = gpar(fontsize = 18))},
             heatmap_legend_param = list(
               title = "Average Log2 FC", at = c(-2.5,0,2.5)))
h
dev.off()

### SUPP FIGURE 5A: Volcano Plot for individual cell lines ####
CSF_Markers_111$p_val_new <- CSF_Markers_111$p_val_adj
CSF_Markers_111$p_val_new[which(CSF_Markers_111$p_val_adj == 0)] <- 1e-304
CSF_Markers_111$log10p_adj <- -log10(CSF_Markers_111$p_val_new)

# add a column for UP and DOWN regulated genes.
CSF_Markers_111$diffexpressed <- "NO"
# if log2Foldchange > 0.5 and pvalue < 50, set as "UP" 
CSF_Markers_111$diffexpressed[CSF_Markers_111$avg_log2FC > 0.5 & CSF_Markers_111$log10p_adj > 50] <- "UP"
# if log2Foldchange < -0.5 and pvalue < 50, set as "DOWN"
CSF_Markers_111$diffexpressed[CSF_Markers_111$avg_log2FC < -0.5 & CSF_Markers_111$log10p_adj > 50] <-  "DOWN"

# add a column of NAs
CSF_Markers_111$delabel <- NA
CSF_Markers_111$delabel[CSF_Markers_111$top20 != "NO"] <- rownames(CSF_Markers_111[CSF_Markers_111$top20 != "NO",])
##CSF_Markers_111$delabel[CSF_Markers_111$top20 != "NO"] <- CSF_Markers_111$X[CSF_Markers_111$top20 != "NO"]

library(ggrepel)
VP <- ggplot(CSF_Markers_111, aes(avg_log2FC, -log10(p_val_new), label=delabel, color=diffexpressed)) + geom_point(alpha = 0.5, size = 3) +
  ##coord_cartesian(xlim= c(-5,3)) + 
  scale_size() +
  theme_minimal() + 
  geom_text_repel(data=CSF_Markers_111, size = 3, max.overlaps = 30, direction = "both") +
  labs(y=expression('-Log'[10]*' P'[adj]), x=expression('Log'[2]*' fold change')) +
  scale_color_manual(values = c("blue","grey27","red")) + 
  theme(legend.position = "none", legend.text = element_text(size = 16), legend.justification = "center",axis.text.x = element_text(size = 16), axis.text.y = element_text(size = 16),axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16), panel.border = element_rect(fill=NA, colour = "black", size=1)) + 
  geom_vline(xintercept = c(-0.5,0,0.5), linetype = "dashed", col = "grey30", size = 0.5) +
  geom_hline(yintercept = c(0.01, 50), linetype = "dashed", col = "grey30", size = 0.5) +
  scale_x_continuous(breaks = seq(-2, 2, by = 1))
VP
ggsave(VP, filename = paste(resultsdirectory, "/plots/Differential expression/VP_top_genes_111_downsampledcells.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)
```

iv. ***FIGURE 6 and SUPP FIGURE 6.***

```{RNA seq Plots for Figure 6 and Supp Figure 6}
## FIGURE 6A: Feature Plot showing expression of NUPR1. ####
FP <- FeaturePlot(Bardy_10x, features = "NUPR1", pt.size = 0.2, label = FALSE, repel = FALSE, split.by = "Condition", cols = c("lightgrey","red"), order = TRUE, keep.scale = "all") & ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "bottom", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=1.5))  & 
  coord_cartesian(xlim = c(-15,15), ylim = c(-15, 15)) 
FP 
ggsave(FP, filename = paste(resultsdirectory, "/plots/UMAP/NUPR1_splitbyCondition_NoLegend.pdf", sep = "/"), height = 6, width = 12, dpi = 300, useDingbats = FALSE)

## SUPP FIGURE 6A: Violin Plot showing expression of NUPR1 across quadrants. ####
GBM_700cells$Condition <- factor(GBM_700cells$Condition, levels = c("CSF","TME"))
VP <- VlnPlot(GBM_700cells, group.by = c("Quadrant"), features = "NUPR1", cols = c("red","black"),split.plot = TRUE, split.by = "Condition", pt.size = 0)  + ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "bottom", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22, angle = 0, hjust = 0), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22, angle = 0), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=0))
VP
ggsave(VP, filename = paste(resultsdirectory, "/plots/Differential expression/GBM_VP_NUPR1_Legend.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)

RP <- RidgePlot(GBM_700cells, features = "NUPR1", group.by = "Condition", sort = "PatientID", log = F)  + ##you can replace the group.by variable to any column on the metadata. Change to "Quiescent.Score" for Figure 3I. 
  theme(legend.position = "none", legend.text = element_text(size = 16), legend.justification = "center")
RP
ggsave(RP, filename = paste0(resultsdirectory,"/plots/Scatterplots/GBM_RP_ProliferationScore_NoLegend.pdf", sep = "/"), height = 6, width = 6, dpi = 300, useDingbats = FALSE)

## SUPP FIGURE 6E: Hierarchical clustering and heatmap of treatment response in GM and CSF. ####
##First we perform a hierarchical clustering to cluster cell lines together. 

##Load data - average viability of cells with treatment. 
##CSF_Treatment <- read.csv(file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/CSF_Treatment.csv"))
##TME_Treatment <- read.csv(file = paste("~/Google Drive/PhD/Bardy_lab_users/Inushi/TME_Treatment.csv"))
All_Treatment <- read.csv(file = paste0(datadirectory, "/reference_sheets/TME_CSF_Treatment.csv"))
All_Treatment <- read.csv(file = paste0(datadirectory, "/reference_sheets/TME_CSF_ki67_Treatment.csv"))

rownames(All_Treatment) <- All_Treatment$X
All_Treatment$X <- NULL
All_Treatment <- t(as.matrix(All_Treatment))

##Perform Clustering 
library(factoextra)

## Function to caluclate a distance matrix by excluding NA values
dist_no_na <- function(All_Treatment) {
    edist <- dist(All_Treatment) ## calulcate dist
    edist[which(is.na(edist))] <- max(edist, na.rm=TRUE) * 1.1 ## get the maximum value, multiply by 1.1 and add to NA values
    return(edist)
}

Dist <- dist(t(All_Treatment)) #Calculate Distance 
Clust <- hclust(Dist)
plot(Clust)
rect.hclust(Clust, h=60)


library(RColorBrewer)
library(ComplexHeatmap)
library(circlize)
library(pals)
library(magick)
library(dendsort)
library(colorspace)

color_h <- colorRamp2(c(0,25,50,75,100,125), c("white","blue","deepskyblue","coral","red","firebrick"))

pdf(file = paste0(resultsdirectory, "/plots/Treatment_Heatmap_wKi67.pdf"), width = 25, height = 10, onefile = T) ##Run to save as pdf

h <- Heatmap(All_Treatment, show_row_names = TRUE,
             show_column_names = T, 
             cluster_columns = function(m) as.dendrogram(Clust), 
             column_dend_reorder = T,
             row_dend_reorder = F,
             cluster_rows = F,
             show_row_dend = F, 
             show_column_dend = TRUE,
             column_dend_height = unit(2, "cm"),
             row_dend_width = unit(2, "cm"),
             col = color_h, ##update colors in previous step
             use_raster = FALSE, 
             raster_device = "png",
             na_col = "grey",
             row_names_gp =  gpar(fontsize = 18),
             column_names_gp =   gpar(fontsize = 18),
             rect_gp = gpar(col = "white", lwd = 1),
             cell_fun = function(j, i, x, y, width, height, fill) {
        grid.text(sprintf("%.1f", All_Treatment[i, j]), x, y, gp = gpar(fontsize = 18))},
             heatmap_legend_param = list(
               title = "Average % Cell Survival", at = c(0,25, 50, 75, 100)))
h
dev.off()
```

v.  ***SUPP FIGURE 10.***
```{Create UMAP and Feature plots - Supplementary Figures 3a-b and 10h-i}
##Use this line to change the order of the factor levels
##Bardy_10x$Condition <- factor(Bardy_10x$Condition, levels = c("TME", "CSF"))

####SUPP FIGURE 10H:UMAP plot by PatientID####
umap <- DimPlot(Bardy_10x, reduction = "umap", pt.size = 0.2, label = FALSE, repel = FALSE, group.by = "PatientID", split.by = "Condition")  + ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "bottom", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=1.5))  + 
  coord_cartesian(xlim = c(-15,15), ylim = c(-15, 15)) 
umap
ggsave(umap, filename = paste0(resultsdirectory, "/plots/UMAP/GBM_PatientID_splitbyCondition_NoLegend.pdf"), height = 6, width = 12, dpi = 300, useDingbats = FALSE)


####SUPP FIGURE 10I:UMAP Plot by Quadrant####
umap <- DimPlot(Bardy_10x, reduction = "umap", pt.size = 0.2, label = FALSE, repel = FALSE, split.by = "Condition", group.by = "Quadrant", cols = c("goldenrod1","red","saddlebrown","royalblue1"))  + ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "bottom", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=1.5))  + 
  coord_cartesian(xlim = c(-15,15), ylim = c(-15, 15)) 
umap
ggsave(umap, filename = paste0(resultsdirectory, "/plots/UMAP/GBM_Quadrant_splitbyCondition_Legend.pdf"), height = 6, width = 12, dpi = 300, useDingbats = FALSE)

#######OPTIONAL: UMAP Plot by Condition####
umap <- DimPlot(Bardy_10x, reduction = "umap", pt.size = 0.2, label = FALSE, repel = FALSE, group.by = "Condition", cols = c("black","red"), split.by = "Condition")  + ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "none", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=1.5))  + 
  coord_cartesian(xlim = c(-15,15), ylim = c(-15, 15)) 
umap
##ggsave(umap, filename = paste0(resultsdirectory, "/plots/UMAP/GBM_Condition_splitbyCondition_NoLegend.pdf"), height = 6, width = 12, dpi = 300, useDingbats = FALSE)

##OPTIONAL: Visualise MESlike1 and MESlike 2. ####
umap <- DimPlot(Bardy_10x, reduction = "umap", pt.size = 0.2, label = FALSE, repel = FALSE, group.by = "MESlike", split.by = "Condition", cols = c("lightsalmon","red","grey79"))  + ##you can replace the group.by variable to any column on the metadata
  theme(legend.position = "none", legend.text = element_text(size = 22), legend.justification = "center", 
        axis.text.x = element_text(size = 22), axis.text.y = element_text(size = 22), 
        axis.title.x = element_text(size = 22), axis.title.y = element_text(size = 22),
        panel.border = element_rect(fill=NA, colour = "black", size=1.5))  + 
  coord_cartesian(xlim = c(-15,15), ylim = c(-15, 15)) 
umap
ggsave(umap, filename = paste0(resultsdirectory, "/plots/UMAP/GBM_MESlike_splitbyCondition_NoLegend.pdf"), height = 6, width = 12, dpi = 300, useDingbats = FALSE)
```

